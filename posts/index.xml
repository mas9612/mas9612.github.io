<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on mas9612&#39;s note</title>
		<link>https://www.mas9612.net/posts/</link>
		<description>Recent content in Posts on mas9612&#39;s note</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<lastBuildDate>Tue, 02 Apr 2019 22:26:20 +0900</lastBuildDate>
		<atom:link href="https://www.mas9612.net/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Linuxのロードアベレージについて</title>
			<link>https://www.mas9612.net/posts/linux-loadavg/</link>
			<pubDate>Tue, 02 Apr 2019 22:26:20 +0900</pubDate>
			
			<guid>https://www.mas9612.net/posts/linux-loadavg/</guid>
			<description>Linuxを使ってサーバ運用をしていると，ロードアベレージという単語をよく聞くかと思う． ふわっとした認識しかなかったので，改めて調査してみた</description>
			<content type="html"><![CDATA[

<p>Linuxを使ってサーバ運用をしていると，ロードアベレージという単語をよく聞くかと思う．
ふわっとした認識しかなかったので，改めて調査してみた．</p>

<h2 id="ロードアベレージとは">ロードアベレージとは</h2>

<p>Linuxの負荷を表す指標の一つ．現在の実行待ちプロセス数の平均と説明されていることが多い．</p>

<h2 id="ロードアベレージを知る方法">ロードアベレージを知る方法</h2>

<p>ロードアベレージはいくつかの方法で知ることができる．</p>

<h3 id="uptimeコマンド">uptimeコマンド</h3>

<p>uptimeコマンドを使うと，システムの稼働時間と同時にロードアベレージが報告される．
ロードアベレージの値は3つ表示され，左から順番に1分，5分，15分の平均を表している．</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ uptime
 <span class="m">23</span>:37:07 up <span class="m">5</span> days, <span class="m">18</span>:41,  <span class="m">1</span> user,  load average: <span class="m">0</span>.00, <span class="m">0</span>.00, <span class="m">0</span>.00</code></pre></div>
<h3 id="wコマンド">wコマンド</h3>

<p>wコマンドは，現在システムにログインしているユーザが表示される．
それと同時に，1行目にuptimeコマンドと同様の内容が出力される．</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ w
 <span class="m">23</span>:37:23 up <span class="m">5</span> days, <span class="m">18</span>:41,  <span class="m">1</span> user,  load average: <span class="m">0</span>.00, <span class="m">0</span>.00, <span class="m">0</span>.00
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
yamazaki pts/0    <span class="m">192</span>.168.56.1     <span class="m">23</span>:17    <span class="m">1</span>.00s  <span class="m">0</span>.04s  <span class="m">0</span>.00s w</code></pre></div>
<h3 id="topコマンド">topコマンド</h3>

<p>topコマンドを使うと，現在動いているプロセスの内容が表示される．
それに加え，ロードアベレージの値が1行目に表示される．</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ top <span class="p">|</span> head
top - <span class="m">23</span>:37:37 up <span class="m">5</span> days, <span class="m">18</span>:41,  <span class="m">1</span> user,  load average: <span class="m">0</span>.00, <span class="m">0</span>.00, <span class="m">0</span>.00
Tasks:  <span class="m">67</span> total,   <span class="m">1</span> running,  <span class="m">66</span> sleeping,   <span class="m">0</span> stopped,   <span class="m">0</span> zombie
%Cpu<span class="o">(</span>s<span class="o">)</span>:  <span class="m">0</span>.0 us,  <span class="m">0</span>.0 sy,  <span class="m">0</span>.0 ni,100.0 id,  <span class="m">0</span>.0 wa,  <span class="m">0</span>.0 hi,  <span class="m">0</span>.0 si,  <span class="m">0</span>.0 st
KiB Mem :  <span class="m">1020332</span> total,   <span class="m">114692</span> free,    <span class="m">64304</span> used,   <span class="m">841336</span> buff/cache
KiB Swap:  <span class="m">1046524</span> total,  <span class="m">1046524</span> free,        <span class="m">0</span> used.   <span class="m">762628</span> avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
    <span class="m">1</span> root      <span class="m">20</span>   <span class="m">0</span>   <span class="m">57104</span>   <span class="m">6868</span>   <span class="m">5276</span> S  <span class="m">0</span>.0  <span class="m">0</span>.7   <span class="m">0</span>:03.66 systemd
    <span class="m">2</span> root      <span class="m">20</span>   <span class="m">0</span>       <span class="m">0</span>      <span class="m">0</span>      <span class="m">0</span> S  <span class="m">0</span>.0  <span class="m">0</span>.0   <span class="m">0</span>:00.04 kthreadd
    <span class="m">3</span> root      <span class="m">20</span>   <span class="m">0</span>       <span class="m">0</span>      <span class="m">0</span>      <span class="m">0</span> S  <span class="m">0</span>.0  <span class="m">0</span>.0   <span class="m">0</span>:01.32 ksoftirqd/0</code></pre></div>
<h3 id="proc-loadavg">/proc/loadavg</h3>

<p><code>/proc/loadavg</code> には，ロードアベレージの値と現在のプロセス数，最後に使用したPIDが記録されている．</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ cat /proc/loadavg
<span class="m">0</span>.00 <span class="m">0</span>.00 <span class="m">0</span>.00 <span class="m">1</span>/73 <span class="m">21068</span></code></pre></div>
<h2 id="ロードアベレージの算出方法">ロードアベレージの算出方法</h2>

<p>それでは，実際にロードアベレージがどのような値を元に算出されているのかを調べていく．
今回は，Linuxカーネル v4.20 のソースコードを使って調査している．</p>

<h3 id="実行待ちプロセス">実行待ちプロセス</h3>

<p>ロードアベレージを計算する時に使われる <strong>現在の実行待ちプロセス数</strong> は，現在存在しているプロセスの中で， <code>TASK_RUNNING</code> もしくは <code>TASK_UNINTERRUPTIBLE</code> と呼ばれる状態のプロセス数を数えたものとなる．</p>

<p><code>TASK_RUNNING</code> 等，プロセスの状態を表す定数は <code>include/linux/sched.h</code> で定義されている．</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Used in tsk-&gt;state: */</span>
<span class="cp">#define TASK_RUNNING            0x0000
</span><span class="cp">#define TASK_INTERRUPTIBLE        0x0001
</span><span class="cp">#define TASK_UNINTERRUPTIBLE        0x0002
</span><span class="cp"></span><span class="p">...</span></code></pre></div>
<p>それぞれの状態がどういう意味を表しているのかは，ps(1)のマニュアルの <code>PROCESS STATE CODES</code> で説明されている．</p>

<ul>
<li><code>TASK_RUNNING</code> : プロセスが実行中もしくは実行可能な状態</li>
<li><code>TASK_UNINTERRUPTIBLE</code> : 割り込み不可能なスリープ状態（IO待ち等）</li>
</ul>

<p>psコマンドの出力を見ると， <code>STAT</code> の列に各プロセスの状態が示されているのがわかる．ここが <code>R</code> の場合は <code>TASK_RUNNING</code> ， <code>D</code> の場合は <code>TASK_UNINTERRUPTIBLE</code> 状態である．</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ ps aux <span class="p">|</span> head
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         <span class="m">1</span>  <span class="m">0</span>.0  <span class="m">0</span>.6  <span class="m">57104</span>  <span class="m">6868</span> ?        Ss   Mar27   <span class="m">0</span>:03 /sbin/init
root         <span class="m">2</span>  <span class="m">0</span>.0  <span class="m">0</span>.0      <span class="m">0</span>     <span class="m">0</span> ?        S    Mar27   <span class="m">0</span>:00 <span class="o">[</span>kthreadd<span class="o">]</span>
root         <span class="m">3</span>  <span class="m">0</span>.0  <span class="m">0</span>.0      <span class="m">0</span>     <span class="m">0</span> ?        S    Mar27   <span class="m">0</span>:01 <span class="o">[</span>ksoftirqd/0<span class="o">]</span>
root         <span class="m">5</span>  <span class="m">0</span>.0  <span class="m">0</span>.0      <span class="m">0</span>     <span class="m">0</span> ?        S&lt;   Mar27   <span class="m">0</span>:00 <span class="o">[</span>kworker/0:0H<span class="o">]</span>
root         <span class="m">7</span>  <span class="m">0</span>.0  <span class="m">0</span>.0      <span class="m">0</span>     <span class="m">0</span> ?        S    Mar27   <span class="m">1</span>:16 <span class="o">[</span>rcu_sched<span class="o">]</span>
root         <span class="m">8</span>  <span class="m">0</span>.0  <span class="m">0</span>.0      <span class="m">0</span>     <span class="m">0</span> ?        S    Mar27   <span class="m">0</span>:00 <span class="o">[</span>rcu_bh<span class="o">]</span>
root         <span class="m">9</span>  <span class="m">0</span>.0  <span class="m">0</span>.0      <span class="m">0</span>     <span class="m">0</span> ?        S    Mar27   <span class="m">0</span>:00 <span class="o">[</span>migration/0<span class="o">]</span>
root        <span class="m">10</span>  <span class="m">0</span>.0  <span class="m">0</span>.0      <span class="m">0</span>     <span class="m">0</span> ?        S&lt;   Mar27   <span class="m">0</span>:00 <span class="o">[</span>lru-add-drain<span class="o">]</span>
root        <span class="m">11</span>  <span class="m">0</span>.0  <span class="m">0</span>.0      <span class="m">0</span>     <span class="m">0</span> ?        S    Mar27   <span class="m">0</span>:01 <span class="o">[</span>watchdog/0<span class="o">]</span></code></pre></div>
<p>これら2つの状態にあるプロセス数をカウントし，それを元にしてロードアベレージを計算していく．
このプロセス数は <code>kernel/sched/loadavg.c</code> で宣言されている <code>calc_load_tasks</code> 変数で管理されており，定期的に呼び出される <code>calc_global_load_tick()</code> 関数で更新される．</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">atomic_long_t</span> <span class="n">calc_load_tasks</span><span class="p">;</span>

<span class="cm">/*
</span><span class="cm"> * Called from scheduler_tick() to periodically update this CPU&#39;s
</span><span class="cm"> * active count.
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">calc_global_load_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">delta</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">calc_load_update</span><span class="p">))</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* 前回の計測と差分があれば，その差分をcalc_load_tasksに適用 */</span>
    <span class="n">delta</span>  <span class="o">=</span> <span class="n">calc_load_fold_active</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">atomic_long_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">calc_load_tasks</span><span class="p">);</span>

    <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">calc_load_update</span> <span class="o">+=</span> <span class="n">LOAD_FREQ</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<p>実際のプロセス数のカウントは <code>calc_global_load_tick()</code> 関数内部で呼び出されている <code>calc_load_fold_active()</code> 関数で行われている．
この関数では，前回カウントしたときのプロセス数と今回のカウント数を比較し，異なっていればその差分を返却するという実装となっている．</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">long</span> <span class="nf">calc_load_fold_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span> <span class="kt">long</span> <span class="n">adjust</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">nr_active</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* TASK_RUNNINGとTASK_UNINTERRUPTIBLEのプロセス数をカウントし，nr_activeに保存 */</span>
    <span class="n">nr_active</span> <span class="o">=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">-</span> <span class="n">adjust</span><span class="p">;</span>
    <span class="n">nr_active</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">nr_uninterruptible</span><span class="p">;</span>

    <span class="cm">/* 前回の計測結果と異なっていれば，差分をdeltaに保存 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nr_active</span> <span class="o">!=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">calc_load_active</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">nr_active</span> <span class="o">-</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">calc_load_active</span><span class="p">;</span>
        <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">calc_load_active</span> <span class="o">=</span> <span class="n">nr_active</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<h3 id="ロードアベレージの計算">ロードアベレージの計算</h3>

<p>実行待ちプロセス数がどのようにカウントされるのかがわかったので，実際のロードアベレージの計算方法について見ていく．
Linuxカーネルでは，ロードアベレージは <code>kernel/sched/loadavg.c</code> で宣言されている <code>avenrun</code> 配列に保存される．</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avenrun</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span></code></pre></div>
<p>この配列は，タイマーによって定期的に呼び出されている <code>kernel/sched/loadavg.c</code> の <code>calc_global_load()</code> 関数で更新される．</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">calc_global_load</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ticks</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sample_window</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">active</span><span class="p">,</span> <span class="n">delta</span><span class="p">;</span>

    <span class="p">...</span>

    <span class="cm">/* 実行待ちプロセス数ををcalc_load_tasksから読み出す */</span>
    <span class="n">active</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">calc_load_tasks</span><span class="p">);</span>
    <span class="n">active</span> <span class="o">=</span> <span class="n">active</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">active</span> <span class="o">*</span> <span class="nl">FIXED_1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* 1，5，15分ごとのロードアベレージをそれぞれ計算する */</span>
    <span class="n">avenrun</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">calc_load</span><span class="p">(</span><span class="n">avenrun</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">EXP_1</span><span class="p">,</span> <span class="n">active</span><span class="p">);</span>
    <span class="n">avenrun</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">calc_load</span><span class="p">(</span><span class="n">avenrun</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">EXP_5</span><span class="p">,</span> <span class="n">active</span><span class="p">);</span>
    <span class="n">avenrun</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">calc_load</span><span class="p">(</span><span class="n">avenrun</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">EXP_15</span><span class="p">,</span> <span class="n">active</span><span class="p">);</span>

    <span class="p">...</span>
<span class="p">}</span></code></pre></div>
<p>この関数を見ると，実際の計算は <code>calc_load()</code> 関数で行っていることがわかる． <code>calc_load()</code> 関数は <code>include/linux/sched/loadavg.h</code> で定義されている．</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm"> * a1 = a0 * e + a * (1 - e)
</span><span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">calc_load</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newload</span><span class="p">;</span>

    <span class="cm">/* load: 前回計算したloadavgの値 */</span>
    <span class="n">newload</span> <span class="o">=</span> <span class="n">load</span> <span class="o">*</span> <span class="n">exp</span> <span class="o">+</span> <span class="n">active</span> <span class="o">*</span> <span class="p">(</span><span class="n">FIXED_1</span> <span class="o">-</span> <span class="n">exp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">active</span> <span class="o">&gt;=</span> <span class="n">load</span><span class="p">)</span>
        <span class="n">newload</span> <span class="o">+=</span> <span class="n">FIXED_1</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">newload</span> <span class="o">/</span> <span class="n">FIXED_1</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<p>ここで，いくつか出てきた定数について整理しておく． <code>calc_global_load()</code> ， <code>calc_load()</code> で出てきた定数はいずれも <code>include/linux/sched/loadavg.h</code> で次のように定義されている．</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define FSHIFT		11		</span><span class="cm">/* nr of bits of precision */</span><span class="cp">
</span><span class="cp">#define FIXED_1		(1&lt;&lt;FSHIFT)	</span><span class="cm">/* 1.0 as fixed-point */</span><span class="cp">
</span><span class="cp">#define EXP_1		1884		</span><span class="cm">/* 1/exp(5sec/1min) as fixed-point */</span><span class="cp">
</span><span class="cp">#define EXP_5		2014		</span><span class="cm">/* 1/exp(5sec/5min) */</span><span class="cp">
</span><span class="cp">#define EXP_15		2037		</span><span class="cm">/* 1/exp(5sec/15min) */</span></code></pre></div>
<p>コメントを見ると， <code>FIXED_1</code> は <code>1</code> を固定小数点で表現しているものだとわかる．そして <code>EXP_*</code> は，それぞれ $e^{\frac{5}{60}}$ ， $e^{\frac{5}{300}}$ ， $e^{\frac{5}{900}}$ の固定小数点表現であることがわかる．</p>

<p>それでは <code>calc_load()</code> に戻って，ロードアベレージを計算している箇所を見てみる．
新しいロードアベレージは， <code>calc_load()</code> の次の行で計算されている．</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c">    <span class="n">newload</span> <span class="o">=</span> <span class="n">load</span> <span class="o">*</span> <span class="n">exp</span> <span class="o">+</span> <span class="n">active</span> <span class="o">*</span> <span class="p">(</span><span class="n">FIXED_1</span> <span class="o">-</span> <span class="n">exp</span><span class="p">);</span></code></pre></div>
<p>これは<a href="https://ja.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87#%E6%8C%87%E6%95%B0%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87">指数移動平均</a>と呼ばれ，最近のデータを重視して古いデータを完全に切り捨てないという特徴を持つ平均のとり方らしい．</p>

<p>このようにして計算された値が，ロードアベレージとして普段目にするものになるようだ．</p>
]]></content>
		</item>
		
		<item>
			<title>プロミスキャスモード（Promiscuous Mode）</title>
			<link>https://www.mas9612.net/posts/promisc-mode/</link>
			<pubDate>Sat, 23 Mar 2019 22:18:44 +0900</pubDate>
			
			<guid>https://www.mas9612.net/posts/promisc-mode/</guid>
			<description>通常，NIC（Network Interface Card）は自分宛て（=自分のMACアドレス宛）のフレームと，ブロードキャスト・マルチキャストのフレームのみを</description>
			<content type="html"><![CDATA[

<p>通常，NIC（Network Interface Card）は自分宛て（=自分のMACアドレス宛）のフレームと，ブロードキャスト・マルチキャストのフレームのみをCPUに渡す．
それ以外のフレームの場合，CPUへの割り込みを行わずに破棄する．</p>

<p>しかし，プロミスキャスモードを有効にすると，宛先MACアドレスが自分宛てかどうかにかかわらず，すべてのフレームをCPUに渡すようになる．
この機能は，主にtcpdumpやWireshark等のパケットキャプチャを行うプログラムで使われている．</p>

<p>ここでは，プロミスキャスモードの設定について簡単にまとめる．</p>

<h2 id="環境">環境</h2>

<p>Debian 9</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ uname -a
Linux debian <span class="m">4</span>.9.0-8-amd64 <span class="c1">#1 SMP Debian 4.9.130-2 (2018-10-27) x86_64 GNU/Linux</span>
$ cat /etc/*-release
<span class="nv">PRETTY_NAME</span><span class="o">=</span><span class="s2">&#34;Debian GNU/Linux 9 (stretch)&#34;</span>
<span class="nv">NAME</span><span class="o">=</span><span class="s2">&#34;Debian GNU/Linux&#34;</span>
<span class="nv">VERSION_ID</span><span class="o">=</span><span class="s2">&#34;9&#34;</span>
<span class="nv">VERSION</span><span class="o">=</span><span class="s2">&#34;9 (stretch)&#34;</span>
<span class="nv">ID</span><span class="o">=</span>debian
<span class="nv">HOME_URL</span><span class="o">=</span><span class="s2">&#34;https://www.debian.org/&#34;</span>
<span class="nv">SUPPORT_URL</span><span class="o">=</span><span class="s2">&#34;https://www.debian.org/support&#34;</span>
<span class="nv">BUG_REPORT_URL</span><span class="o">=</span><span class="s2">&#34;https://bugs.debian.org/&#34;</span></code></pre></div>
<h2 id="プロミスキャスモードの設定">プロミスキャスモードの設定</h2>

<p>プロミスキャスモードの設定は，コマンドを用いる方法とプログラムから設定する方法の2つがある．
それぞれの設定方法を見ていく．</p>

<h3 id="コマンドによる設定">コマンドによる設定</h3>

<p><code>ip</code> コマンドと <code>ifconfig</code> 2種類が使えるが， <code>ifconfig</code> はすでに非推奨となっているため， <code>ip</code> コマンドを使った方法で行う．</p>

<p><code>ip</code> コマンドを使ってプロミスキャスモードを有効にするには， <code>ip link set &lt;device name&gt; promisc on</code> と実行する．
なお，設定には特権が必要である．</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ ip a show enp0s8
<span class="m">3</span>: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc pfifo_fast state UP group default qlen <span class="m">1000</span>
    link/ether <span class="m">08</span>:00:27:75:06:24 brd ff:ff:ff:ff:ff:ff
    inet <span class="m">192</span>.168.56.80/24 brd <span class="m">192</span>.168.56.255 scope global enp0s8
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fe75:624/64 scope link
       valid_lft forever preferred_lft forever

$ ip link <span class="nb">set</span> enp0s8 promisc on
RTNETLINK answers: Operation not permitted
$ sudo ip link <span class="nb">set</span> enp0s8 promisc on

$ ip a show enp0s8
<span class="m">3</span>: enp0s8: &lt;BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc pfifo_fast state UP group default qlen <span class="m">1000</span>
    link/ether <span class="m">08</span>:00:27:75:06:24 brd ff:ff:ff:ff:ff:ff
    inet <span class="m">192</span>.168.56.80/24 brd <span class="m">192</span>.168.56.255 scope global enp0s8
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fe75:624/64 scope link
       valid_lft forever preferred_lft forever</code></pre></div>
<h3 id="プログラムによる設定">プログラムによる設定</h3>

<p>プログラムから設定するには，ioctl(2)で <code>SIOCSIFFLAGS</code> を使用する．
<code>ip</code> コマンドと同様，設定には特権が必要である．</p>

<p>サンプルプログラムは <a href="https://github.com/mas9612/study/blob/master/networking/promiscuous_mode/promisc_sample.c">study/promisc_sample.c at master · mas9612/study</a> にあります．</p>

<p>実際にプロミスキャスモードを設定している部分は次の部分．</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c">    <span class="c1">// set promiscuous mode
</span><span class="c1"></span>    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ifr</span><span class="p">));</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">soc</span><span class="p">,</span> <span class="n">SIOCGIFFLAGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;failed to get interface flag&#34;</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">soc</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ifr</span><span class="p">.</span><span class="n">ifr_flags</span> <span class="o">|=</span> <span class="n">IFF_PROMISC</span><span class="p">;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">soc</span><span class="p">,</span> <span class="n">SIOCSIFFLAGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;failed to set interface flag&#34;</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">soc</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span></code></pre></div>
<p>まず， <code>SIOCGIFFLAGS</code> で現在NICに設定されているフラグを取得して，それに <code>IFF_PROMISC</code> フラグを追加するという形で設定する．
プログラムをコンパイルし，実行してみるとうまく設定されていることが確認できる．</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># ensure promisc mode is off before run program</span>
$ sudo ip link <span class="nb">set</span> enp0s8 promisc off
$ ip a show enp0s8
<span class="m">3</span>: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc pfifo_fast state UP group default qlen <span class="m">1000</span>
    link/ether <span class="m">08</span>:00:27:75:06:24 brd ff:ff:ff:ff:ff:ff
    inet <span class="m">192</span>.168.56.80/24 brd <span class="m">192</span>.168.56.255 scope global enp0s8
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fe75:624/64 scope link
       valid_lft forever preferred_lft forever

$ gcc -Wall promisc_sample.c
$ ./a.out enp0s8
failed to create socket: Operation not permitted
$ sudo ./a.out enp0s8

$ ip a show enp0s8
<span class="m">3</span>: enp0s8: &lt;BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc pfifo_fast state UP group default qlen <span class="m">1000</span>
    link/ether <span class="m">08</span>:00:27:75:06:24 brd ff:ff:ff:ff:ff:ff
    inet <span class="m">192</span>.168.56.80/24 brd <span class="m">192</span>.168.56.255 scope global enp0s8
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fe75:624/64 scope link
       valid_lft forever preferred_lft forever</code></pre></div>
<h2 id="おわりに">おわりに</h2>

<p>今回は設定する方法のみをまとめたが，プロミスキャスモードを検出する方法もいくつかあるようなので，今後検証したい．</p>

<h2 id="references">References</h2>

<ul>
<li><a href="http://www.just.edu.jo/~tawalbeh/nyit/incs745/presentations/Sniffers.pdf">Sniffers Basics and Detection</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Linux PAMについて</title>
			<link>https://www.mas9612.net/posts/linux-pam/</link>
			<pubDate>Sat, 02 Mar 2019 23:13:05 +0900</pubDate>
			
			<guid>https://www.mas9612.net/posts/linux-pam/</guid>
			<description>LDAPと連携させてLinuxサーバにログインしたいとき等，PAMの設定をいじることは今までにもあった． しかし，PAMについてしっかりと理解</description>
			<content type="html"><![CDATA[

<p>LDAPと連携させてLinuxサーバにログインしたいとき等，PAMの設定をいじることは今までにもあった．
しかし，PAMについてしっかりと理解できているわけではなかったので，PAMやその設定について調査した．</p>

<h2 id="pamとは">PAMとは</h2>

<p>マニュアルによると，PAM（Pluggable Authentication Module）はシステム上のアプリケーション（サービス）による認証を処理するためのライブラリであるとのこと．
API経由で認証タスクを呼び出すことができるので，アプリケーション側で認証のやり方等の深いところまで考えることなく使えるよ，という感じ．</p>

<blockquote>
<p>Linux-PAM is a system of libraries that handle the authentication tasks of applications (services) on the system.
The library provides a stable general interface (Application Programming Interface - API) that privilege granting programs (such as login(1) and su(1)) defer to to perform standard authentication tasks.</p>
</blockquote>

<p>PAMでは，認証に関するタスクを役割ごとに次の4つのグループに分け，それぞれのグループごとに設定できる．</p>

<ul>
<li>account: ユーザパスワードの期限が切れていないか，要求しているサービスにアクセスする権限があるか，等を検証</li>
<li>authentication: パスワード等によるユーザ認証を行う部分．認証方法は問わない（パスワード，ハードウェアトークン等）</li>
<li>password: 例えばパスワード認証の場合，パスワードの変更等に関連する部分を担当する（e.g. 弱いパスワードでないか，前回と同じでないか等）</li>
<li>session: サービス利用前と利用後に実施される処理について．e.g. ログやユーザディレクトリのマウント等</li>
</ul>

<h2 id="pamの設定">PAMの設定</h2>

<p>PAMの設定は <code>/etc/pam.conf</code> もしくは <code>/etc/pam.d/</code> 以下のファイルによって行う．
<code>/etc/pam.d/</code> が存在している場合は， <code>/etc/pam.conf</code> は無視されて <code>/etc/pam.d/</code> 以下のファイルにある設定が有効となる．</p>

<p>設定のフォーマットは次の通り．基本的に1行に1つの設定を書いていく感じ．</p>

<pre><code>service type control module-path module-arguments
</code></pre>

<p>なお，先頭が <code>#</code> の場合はコメントとなる．</p>

<p><code>/etc/pam.conf</code> と <code>/etc/pam.d</code> 以下のファイルは基本的に設定フォーマットは同じである．
しかし， <code>/etc/pam.d/</code> 以下のファイルでは，そのファイル名自体が <code>service</code> を示すため，1カラム目にある <code>service</code> は省略される．</p>

<h3 id="service">service</h3>

<p>serviceは，設定が反映される対象のアプリケーションを示す．
例えば，serviceが <code>sshd</code> の場合（ <code>/etc/pam.d/sshd</code> ）はSSHサーバのデーモンに対しての設定が記述される．</p>

<h3 id="type">type</h3>

<p>typeは，その行にある設定が上記4つの内どのグループの設定かを示す．</p>

<ul>
<li><code>account</code></li>
<li><code>auth</code></li>
<li><code>password</code></li>
<li><code>session</code></li>
</ul>

<h3 id="control">control</h3>

<p>単純な設定と複雑な設定があるが，単純な設定の場合に有効な値は次の通り．</p>

<ul>
<li>required: モジュールから返ってきた結果がfailure（失敗）だった場合，PAM全体としての返却値もfailureになる．しかし，後に続く設定は引き続き評価される．</li>
<li>requisite: 基本はrequiredと同じ．requiredと異なり，モジュールの返却値がfailureだった場合はそこで即座に終了し，後に続く設定は評価されない．</li>
<li>sufficient: モジュールの返却値が成功なら，そこで処理を終了してPAMも成功を返却する．後に続く設定は評価されない．モジュールの返却値が失敗なら引き続き後に続く設定の評価に移る．</li>
<li>optional: このモジュールの結果は，このモジュールが唯一の設定であった場合のみ有効となる．

<ul>
<li>e.g.) sshdのauthタイプとして設定されているモジュールが一つだけ存在し，それのcontrolがoptionalである場合</li>
</ul></li>
<li>include: 他のファイルに定義されている設定を読みこむ．</li>
<li>substack: includeと同様に他のファイルから設定を読み込むが，その中に即座に評価を終了するような設定がその中にあった場合（e.g. requisite），その効力は読み込んだファイルに対してのみ有効となる

<ul>
<li>e.g.) substackの中で定義されているrequisiteが失敗した場合，substack内の評価のみがそこで終了し，substackを呼び出した側の評価は終了せずに引き続き続行される．</li>
<li>スコープが分かれるイメージ</li>
</ul></li>
</ul>

<p>複雑な方の設定は今回確認するファイルの中には出てこなかったので割愛する．</p>

<h3 id="module-path-module-arguments">module-path, module-arguments</h3>

<p>適用されるPAMモジュールのパスとその引数を指定する．
モジュールは共有ライブラリとなっており， <code>/lib64/security/</code> の下にあるかと思う．
それぞれのモジュールについての説明は， <code>man</code> コマンドで確認することができる（e.g. <code>man pam_unix</code> ）．</p>

<h2 id="sshdの設定を見てみる">sshdの設定を見てみる</h2>

<p>PAMがどういったものかというのは簡単に理解できたので，実際に設定を見てみる．
今回は，LDAPログインの設定でも編集対象となるsshdの設定ファイルを見ることにする．
なお，一つ一つのモジュールについて逐一説明を入れていくとキリがないので，モジュール自体の説明は一部に留める．</p>

<p>今回使用している環境はCentOS 7である．</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ cat /etc/redhat-release
CentOS Linux release <span class="m">7</span>.6.1810 <span class="o">(</span>Core<span class="o">)</span></code></pre></div>
<p><code>/etc/pam.d/sshd</code> の中身は次のようになっていた．</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ cat /etc/pam.d/sshd
<span class="c1">#%PAM-1.0</span>
auth       required     pam_sepermit.so
auth       substack     password-auth
auth       include      postlogin
<span class="c1"># Used with polkit to reauthorize users in remote sessions</span>
-auth      optional     pam_reauthorize.so prepare
account    required     pam_nologin.so
account    include      password-auth
password   include      password-auth
<span class="c1"># pam_selinux.so close should be the first session rule</span>
session    required     pam_selinux.so close
session    required     pam_loginuid.so
<span class="c1"># pam_selinux.so open should only be followed by sessions to be executed in the user context</span>
session    required     pam_selinux.so open env_params
session    required     pam_namespace.so
session    optional     pam_keyinit.so force revoke
session    include      password-auth
session    include      postlogin
<span class="c1"># Used with polkit to reauthorize users in remote sessions</span>
-session   optional     pam_reauthorize.so prepare</code></pre></div>
<p>設定ファイルは上から順番に評価されていくので，設定を読むときも上から順番に読んでいく．</p>

<p>authに関連する部分を見てみる．
auth関連の部分は次の4行（コメントを除く）．</p>

<pre><code>auth       required     pam_sepermit.so
auth       substack     password-auth
auth       include      postlogin
# Used with polkit to reauthorize users in remote sessions
-auth      optional     pam_reauthorize.so prepare
</code></pre>

<p>1つ目の <code>pam_sepermit.so</code> は，このユーザはSELinuxが有効になっている場合のみログインを許可する，といった設定が可能になるモジュール．</p>

<p>2つ目と3つ目は，それぞれ <code>/etc/pam.d/password-auth</code> と <code>/etc/pam.d/postlogin</code> というファイルから設定を読み込んでいる．
2つ目は <code>substack</code> となっているので，もし <code>password-auth</code> の中でrequisiteのように即座に評価を終了するものが適用された場合は，その段階で <code>password-auth</code> の評価が終了するだけで引き続き次の<code>postlogin</code> の評価に移る．</p>

<p>4つ目の <code>auth</code> には，頭に <code>-</code> がついている．これは，もしモジュールが存在しなかった場合はこの行を無視して次に進むということを意味している．</p>

<p>次に，password-authとpostloginの部分について見てみる．
なお， <code>include</code> や <code>substack</code> は，それが書かれたtypeに関する設定のみを読み込む．今回だと <code>auth</code> の部分のみを読み込む．</p>

<pre><code>$ cat /etc/pam.d/password-auth | grep -E '^-?auth'
auth        required      pam_env.so
auth        required      pam_faildelay.so delay=2000000
auth        sufficient    pam_unix.so nullok try_first_pass
auth        requisite     pam_succeed_if.so uid &gt;= 1000 quiet_success
auth        required      pam_deny.so
$ cat /etc/pam.d/postlogin | grep -E '^-?auth'
</code></pre>

<h2 id="おわりに">おわりに</h2>

<p>PAMとは何か，どのようにPAMを設定していくのかについて調査した．
PAM APIの方針に従っていれば，自由に新しいモジュールを作成することができるので，理解を深めるためになにか簡単なモジュールでも作ってみようかと考えている．</p>

<h2 id="references">References</h2>

<ul>
<li>PAM(8)</li>
<li>pam.conf(5)</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Linux Namespaces (1)</title>
			<link>https://www.mas9612.net/posts/linux-namespaces-01/</link>
			<pubDate>Mon, 18 Feb 2019 23:24:23 +0900</pubDate>
			
			<guid>https://www.mas9612.net/posts/linux-namespaces-01/</guid>
			<description>前回は chroot(2) について調査・テストしたので，今回はnamespacesについて勉強した． 少々長いので，2つの記事に分けて投稿する． 今回使った環境は</description>
			<content type="html"><![CDATA[

<p>前回は chroot(2) について調査・テストしたので，今回はnamespacesについて勉強した．
少々長いので，2つの記事に分けて投稿する．</p>

<p>今回使った環境はDebian 9 Stretch．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ uname -a
Linux debian <span class="m">4</span>.9.0-8-amd64 <span class="c1">#1 SMP Debian 4.9.130-2 (2018-10-27) x86_64 GNU/Linux</span></code></pre></div>
<h2 id="namespacesについて">namespacesについて</h2>

<p>namespacesは，Linuxが持つシステムリソースをプロセスごとに分離するための技術．
これを用いると，異なるnamespace間でネットワークやPID等の資源を独立して持つことができるようになる．</p>

<p>Linux namespacesでは，次の7つが提供されている．</p>

<ul>
<li>Cgroup namespace</li>
<li>IPC namespaces</li>
<li>Network namespaces</li>
<li>Mount namespaces</li>
<li>PID namespaces</li>
<li>User namespaces</li>
<li>UTS namespaces</li>
</ul>

<p>それぞれのnamespacesについては以下の節で順番に説明していく．</p>

<h2 id="namespacesを使うためのシステムコール">namespacesを使うためのシステムコール</h2>

<p>新しいnamespaceを作成してそれを使用するには，次の2つのどちらかを使用する．</p>

<ul>
<li>clone(2)

<ul>
<li>新しいプロセスを作成するとともに，引数に指定したフラグに対応する新しいnamespaceを作成し，新しいプロセスをそれに所属させる</li>
</ul></li>
<li>unshare(2)

<ul>
<li>システムコールを呼び出したプロセスを新しいnamespaceに移動させる．</li>
</ul></li>
</ul>

<p>また，プロセスを <strong>既存の</strong> namespaceに移動させるには，setns(2)システムコールを使用する．</p>

<p>User namespacesを除き，新しいnamespaceを作成するには特権（ <code>CAP_SYS_ADMIN</code> ）が必要となる．</p>

<h2 id="proc-pid-nsディレクトリ">/proc/[pid]/nsディレクトリ</h2>

<p><code>/proc/[pid]/ns</code> ディレクトリ内には，そのプロセスが所属している各namespaceを表すエントリがおかれている．これらは，setns(2)システムコールで操作することができる．</p>

<p>例えば，すでに動作しているプロセスのnamespaceに入りたい場合は，次のようにすることで可能．</p>

<ol>
<li>入りたいnamespaceに所属しているプロセスのnsディレクトリ内にある適切なエントリ（e.g. Network namespacesなら <code>net</code> ）をオープン</li>
<li>オープンしたファイルディスクリプタをsetns(2)の引数に渡してあげる</li>
</ol>

<h2 id="pid-namespaces">PID namespaces</h2>

<p>比較的わかりやすいPID namespacesから順番に見ていく．</p>

<p>PID namespacesは，その名の通りPIDの空間を分離するために用いられる．
異なるPID namespace間では異なるプロセスツリーを持ち，それらはそれぞれ独立している．
そのため，異なるPID namespace間で同じPIDを持つ可能性もある．</p>

<p>unshare(2)システムコールを使って新しいPID namespaceを作成し，そこに子プロセスを所属させるという簡単なプログラムを使ってテストした．</p>

<p>プログラム全体は<a href="https://github.com/mas9612/study/blob/master/container/pid_namespace.c">GitHub</a>にpushしている．</p>

<p>新しいPID namespaceを作成するためには，unshare(2)の引数に <code>CLONE_NEWPID</code> を指定する．
unshare(2)を呼び出した以降に作成した子プロセスは，新しいPID namespace内で実行される（新しいPID namespaceでは，PIDは1から順番に振られる）．</p>

<p><strong>unshare(2)を呼び出したプロセス自体は，これまでと同じPID namespaceで動作していることに注意</strong>．
このため，サンプルプログラムではfork(2)を使って子プロセスを作成することで動作確認をしている．</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c">    <span class="n">ret</span> <span class="o">=</span> <span class="n">unshare</span><span class="p">(</span><span class="n">CLONE_NEWPID</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;unshare()&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span></code></pre></div>
<p>サンプルプログラムを実行すると次のような実行結果が得られる．</p>

<pre><code>$ gcc pid_namespaces.c
$ sudo ./a.out
PID: 5516
Forking new process...
  Child PID: 5517

Create new PID namespaces...
PID: 5516
Forking new process...
  Child PID: 1
</code></pre>

<p>この結果から次のことが読み取れる．</p>

<ul>
<li>unshare(2)を呼び出したプロセス自体（PID 5516）はPID namespaceの移動はしていない</li>
<li>unshare(2)を呼び出す前の子プロセスはPID 5516と同じPID namespaceに所属しているので，PIDはその続き（PID 5517）となっている</li>
<li>unshare(2)を呼び出した後の子プロセスは新しいPID namespaceに所属しているので，PIDは1となっている</li>
</ul>

<h2 id="network-namespaces">Network namespaces</h2>

<p>次はNetwork namespacesについて見ていく．</p>

<p>名前の通りで理解しやすいと思うが，ネットワーク関連のリソースを分離するための技術．
ネットワークデバイスやIPプロトコルスタック，ルーティングテーブルやファイアウォールルール等をnamespaceごとで分離することができる．
各ネットワークデバイスは1つのnetwork namespacesのみに割り当てられる．</p>

<p>これも<a href="https://github.com/mas9612/study/blob/master/container/network_namespaces.c">サンプルプログラム</a>を書いて試してみた．
サンプルでは， <code>ip a</code> コマンドを使ってネットワークデバイスの情報を出力してみた．</p>

<p>新しいnetwork namespaceに移動するには，unshare(2)の引数に <code>CLONE_NEWNET</code> を渡してあげれば良い．</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c">    <span class="n">ret</span> <span class="o">=</span> <span class="n">unshare</span><span class="p">(</span><span class="n">CLONE_NEWNET</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;unshare()&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span></code></pre></div>
<p>サンプルプログラムを実行するとつぎのような実行結果が得られる．</p>

<pre><code>$ gcc network_namespaces.c
$ sudo ./a.out
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:ad:47:43 brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global enp0s3
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fead:4743/64 scope link
       valid_lft forever preferred_lft forever
3: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:75:06:24 brd ff:ff:ff:ff:ff:ff
    inet 192.168.56.80/24 brd 192.168.56.255 scope global enp0s8
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fe75:624/64 scope link
       valid_lft forever preferred_lft forever

Enter new network namespace:
1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</code></pre>

<p>実行結果から，network namespaceを移動した後の <code>ip a</code> では，ループバックデバイス以外のネットワークデバイスが割り当てられていないことがわかる．
ネットワークデバイスは一度に1つのnetwork namespaceにしか所属できないので，新しいnetwork namespaceに移動した後の <code>ip a</code> の出力には現れなかった．</p>

<h2 id="uts-namespaces">UTS namespaces</h2>

<p>UTS namespacesは，ホスト名およびNISドメイン名をnamespaceごとに分離するための技術．
これを用いると，各UTS namespaceごとにそれぞれ個別のホスト名をつけることができる．</p>

<p>プログラムを書いて検証するのが少し面倒なので，unshare(1)コマンドで試す．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ hostname
debian
$ sudo unshare --uts
<span class="o">[</span>sudo<span class="o">]</span> password <span class="k">for</span> yamazaki:

<span class="c1"># hostname</span>
debian
<span class="c1"># hostname inside-uts-namespace</span>
<span class="c1"># hostname</span>
inside-uts-namespace
<span class="c1"># exit</span>
<span class="nb">logout</span>

$ hostname
debian</code></pre></div>
<p><code>unshare --uts</code> コマンドで，新しいUTS namespaceを作成してそれに移動することができる．
その後， <code>hostname</code> コマンドを使って適当なホスト名をセットしてみる．</p>

<p>正常にホスト名が変更できたことを確認して，作成したUTS namespaceからexitで抜ける．
抜けた後にもう一度ホスト名を確認してみると，UTS namespace内で行った変更が反映されておらず，namespaceごとで独立していたことがわかる．</p>

<h2 id="references">References</h2>

<ul>
<li>namespaces(7)</li>
<li>unshare(2)</li>
<li>setns(2)</li>
<li>pid_namespaces(7)</li>
<li>network_namespaces(7)</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>chrootの基礎</title>
			<link>https://www.mas9612.net/posts/chroot-basic/</link>
			<pubDate>Tue, 12 Feb 2019 00:40:00 +0900</pubDate>
			
			<guid>https://www.mas9612.net/posts/chroot-basic/</guid>
			<description>DockerやKubernetesといったコンテナ関連の技術にはよくお世話になっているが，コンテナの実装やそれを実現している技術については深</description>
			<content type="html"><![CDATA[

<p>DockerやKubernetesといったコンテナ関連の技術にはよくお世話になっているが，コンテナの実装やそれを実現している技術については深く知らなかった．
しかし，詳細を知らないまま使い続けるのは少し気持ち悪いので，少しずつ勉強していくことにする．</p>

<p>今回はまず手始めに，chrootについて勉強した．</p>

<h2 id="chrootとは">chrootとは</h2>

<p>chroot (change root) とは，名前の通り呼び出したプロセスのルートディレクトリを変更することができる仕組みのこと．</p>

<blockquote>
<p>chroot() changes the root directory of the calling process to that specified in path</p>
</blockquote>

<p>chroot(2) より引用</p>

<p>chrootによって変更されたルートディレクトリは，fork等で生成された子プロセスにも引き継がれる．</p>

<h2 id="chrootの使い方">chrootの使い方</h2>

<p>chrootは， <code>chroot</code> コマンドを使ってコマンドラインで使用する方法と，chroot(2)システムコールを使ってプログラムから呼び出す方法がある．
以降，2つの方法について順番に説明する．</p>

<h3 id="chrootコマンドを使う">chrootコマンドを使う</h3>

<p>chrootコマンドの使い方は以下の通り．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ chroot <span class="o">[</span>OPTION<span class="o">]</span> NEWROOT <span class="o">[</span>COMMAND <span class="o">[</span>ARG<span class="o">]</span>...<span class="o">]</span></code></pre></div>
<p><code>chroot</code> の後に，新しいルートディレクトリとして設定したいディレクトリを指定する．
また，その後に実行したいコマンドを指定することもできるが，これを省略すると <code>${SHELL} -i</code> が実行される．</p>

<p>ちなみに，rootユーザ（正確には <code>CAP_SYS_CHROOT</code> capabilityを持つユーザ）のみがこのコマンドを実行することができる．</p>

<p>試しに <code>chroot_test</code> ディレクトリを作成して，それを新しいルートディレクトリとしてbashを起動してみる．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ mkdir chroot_test 
<span class="c1"># 通常ユーザでは権限が足りずにエラーとなる</span>
$ chroot chroot_test bash
chroot: cannot change root directory to chroot_test/: Operation not permitted

$ sudo chroot chroot_test bash
chroot: failed to run <span class="nb">command</span> ‘/bin/bash’: No such file or directory</code></pre></div>
<p><code>sudo</code> を使ってrootとして <code>chroot</code> を実行すると，権限の問題はなくなったがbashが見つからないというエラーになった．
chrootによってルートディレクトリが変更されると元々の <code>/bin</code> にはアクセスできなくなるので，chroot先にbashコマンドを用意してあげる必要がある．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ mkdir chroot chroot_test/bin
$ cp <span class="sb">`</span>which bash<span class="sb">`</span> chroot_test/bin
$ sudo chroot chroot_test bash
chroot: failed to run <span class="nb">command</span> ‘/bin/bash’: No such file or directory

<span class="c1"># lsコマンドの実行にはいくつか動的ライブラリが必要となるので，</span>
<span class="c1"># それもchroot先に用意してあげなければならない</span>
$ ldd <span class="sb">`</span>which bash<span class="sb">`</span>
        linux-vdso.so.1 <span class="o">=</span>&gt;  <span class="o">(</span>0x00007ffc956cb000<span class="o">)</span>
        libselinux.so.1 <span class="o">=</span>&gt; /lib64/libselinux.so.1 <span class="o">(</span>0x00007fe3914d4000<span class="o">)</span>
        libcap.so.2 <span class="o">=</span>&gt; /lib64/libcap.so.2 <span class="o">(</span>0x00007fe3912cf000<span class="o">)</span>
        libacl.so.1 <span class="o">=</span>&gt; /lib64/libacl.so.1 <span class="o">(</span>0x00007fe3910c6000<span class="o">)</span>
        libc.so.6 <span class="o">=</span>&gt; /lib64/libc.so.6 <span class="o">(</span>0x00007fe390cf9000<span class="o">)</span>
        libpcre.so.1 <span class="o">=</span>&gt; /lib64/libpcre.so.1 <span class="o">(</span>0x00007fe390a97000<span class="o">)</span>
        libdl.so.2 <span class="o">=</span>&gt; /lib64/libdl.so.2 <span class="o">(</span>0x00007fe390893000<span class="o">)</span>
        /lib64/ld-linux-x86-64.so.2 <span class="o">(</span>0x00007fe3916fb000<span class="o">)</span>
        libattr.so.1 <span class="o">=</span>&gt; /lib64/libattr.so.1 <span class="o">(</span>0x00007fe39068e000<span class="o">)</span>
        libpthread.so.0 <span class="o">=</span>&gt; /lib64/libpthread.so.0 <span class="o">(</span>0x00007fe390472000<span class="o">)</span>
$ cp /lib64/libtinfo.so.5 /lib64/libdl.so.2 /lib64/libc.so.6    <span class="se">\
</span><span class="se"></span>    /lib64/ld-linux-x86-64.so.2 chroot_test/lib64
$ sudo chroot chroot_test bash
bash-4.2# <span class="nb">pwd</span>
/
bash-4.2# ls
bash: ls: <span class="nb">command</span> not found
bash-4.2# <span class="nb">exit</span>
<span class="nb">exit</span>

$ cp <span class="sb">`</span>which ls<span class="sb">`</span> chroot_test/bin
$ cp /lib64/libselinux.so.1 /lib64/libcap.so.2 /lib64/libacl.so.1   <span class="se">\
</span><span class="se"></span>    /lib64/libpcre.so.1 /lib64/libdl.so.2 /lib64/libattr.so.1       <span class="se">\
</span><span class="se"></span>    /lib64/libpthread.so.0 chroot_test/lib64
$ sudo chroot chroot_test bash
bash-4.2# <span class="nb">pwd</span>
/
bash-4.2# ls
bin  lib64
bash-4.2# <span class="nb">exit</span>
exit</code></pre></div>
<h3 id="chroot-2-システムコールを使う">chroot(2)システムコールを使う</h3>

<p>chroot(2)システムコールは次のような関数となっている．</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">chroot</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span></code></pre></div>
<p>引数に新しいルートディレクトリとなるパスを指定する．
成功すると <code>0</code> ，失敗すると <code>-1</code> が返却されて <code>errno</code> が設定される．</p>

<p><a href="https://github.com/mas9612/study/blob/master/container/chroot_basic.c">サンプルプログラム</a>はGitHubにあります．</p>

<p>注意点として，chroot(2)を使っても，パスの解決方法が変わるだけでカレントディレクトリは変更されない．
なので，サンプルプログラムでは予めchroot先に移動してからchroot(2)を実行している．</p>

<p>もしchdir(2)なしでchroot(2)を実行すると，カレントディレクトリは変更されない．
この状態でgetcwd(2)を呼び出した場合，カレントディレクトリがルートディレクトリの外となるため，エラーとなってしまう．</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c">    <span class="n">ret</span> <span class="o">=</span> <span class="n">chdir</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;chdir()&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">chroot</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;chroot()&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">getcwd</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;getcwd()&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span></code></pre></div>
<h2 id="chrootを抜け出す">chrootを抜け出す</h2>

<p>前節で，chroot(2)を使ってもカレントディレクトリは変更されないということを述べた．
これを利用して，chroot(2)を使う権限があるプロセスがchrootの外に抜け出すことが可能になる．</p>

<p>ここではこれを試してみる．
プログラムの全体は<a href="https://github.com/mas9612/study/blob/master/container/chroot_escape.c">GitHub</a>にあります．</p>

<p>やることは簡単で，つぎのような順番で処理を進めていく．</p>

<ol>
<li>chrootによって設定されたルートディレクトリに移動</li>
<li>適当なサブディレクトリを作成</li>
<li>作成したサブディレクトリにchroot</li>
<li>一つ上の階層に移動する</li>
</ol>

<p>これで，元々のchrootされたルートディレクトリの一つ上に移動することができる．</p>

<p>プログラムにすると次のようになる．</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c">    <span class="c1">// create foo directory and chroot to it
</span><span class="c1"></span>    <span class="n">ret</span> <span class="o">=</span> <span class="n">mkdir</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="mo">0755</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;mkdir()&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">chroot</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;chroot()&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="c1">// after chroot to foo directory, attempt to escape upper directory
</span><span class="c1"></span>    <span class="c1">// than original chrooted directory (chroot_test directory)
</span><span class="c1"></span>    <span class="n">ret</span> <span class="o">=</span> <span class="n">chdir</span><span class="p">(</span><span class="s">&#34;..&#34;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;chdir()&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span></code></pre></div>
<p>chrootはパスの解決方法を変更しているだけであり，複数適用させることができない．
そのため，2回目のchroot(2)呼び出しを行うと前回のchrootで設定した効果はなくなり，新しいものだけが効力を持つ．</p>

<p>上の手順を進めると，作成したサブディレクトリにchrootした段階で，元々のchrootの効果はなくなる．
また，chrootはカレントディレクトリを変更しないという性質より，手順3. の時点ですでにルートディレクトリの外にいることになる．</p>

<p>この状態では上の階層への移動が可能なので，結果的に元々のchrootされたルートディレクトリより上に移動することが実現できる．</p>

<p>実は，このことはchroot(2)のマニュアルにも記されており，仕様通りのようだ．</p>

<blockquote>
<p>This call does not change the current working directory, so that after the call &lsquo;.&rsquo; can be outside the tree rooted at &lsquo;/&rsquo;.  In  particular,  the  supe‐
ruser can escape from a &ldquo;chroot jail&rdquo; by doing:</p>

<pre><code>mkdir foo; chroot foo; cd ..
</code></pre>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>GoでのファイルI/O</title>
			<link>https://www.mas9612.net/posts/go-file-io/</link>
			<pubDate>Sun, 13 Jan 2019 00:00:00 +0900</pubDate>
			
			<guid>https://www.mas9612.net/posts/go-file-io/</guid>
			<description>GoでのファイルI/Oについて，改めてまとめた． いろいろな方法があるので，それぞれどういったものかを確認しながらまとめる． ファイルオープン 読</description>
			<content type="html"><![CDATA[

<p>GoでのファイルI/Oについて，改めてまとめた．
いろいろな方法があるので，それぞれどういったものかを確認しながらまとめる．</p>

<h2 id="ファイルオープン">ファイルオープン</h2>

<p>読み書きを行う前に，まずファイルオープンしないとどうにもならないのでそこから．
osパッケージを見ると，2つのファイルオープンメソッドがあることがわかる．</p>

<ul>
<li><code>os.Open</code></li>
<li><code>os.OpenFile</code></li>
</ul>

<h3 id="os-open">os.Open</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Open</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span></code></pre></div>
<p>引数に与えられた名前のファイルを <strong>読み取り専用</strong> でオープンする．
そのため，もしファイルが存在しなければエラーとなる（ <code>*PathError</code> が返却される）</p>

<p>例</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// os.Open attempts to open given file as read only mode.
</span><span class="c1">// Therefore, if it doesn&#39;t exist, then *os.PathError will occur.
</span><span class="c1"></span><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;thisdoesntexist.txt&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">os</span><span class="p">.</span><span class="nf">IsNotExist</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;file not found&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>上の例では便利メソッドとして <code>os.IsNotExist</code> を使っている．
このメソッドに <code>os.Open</code> から返却されたエラーを渡すと，ファイルが存在しないために発生したエラーかどうかを教えてくれる．
<code>os.IsNotExist</code> の返り値が <code>true</code> なら，ファイルが存在しないという意味になる．</p>

<h3 id="os-openfile">os.OpenFile</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">OpenFile</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">flag</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">perm</span> <span class="nx">FileMode</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span></code></pre></div>
<p>引数に与えられた名前のファイルを，指定したモード，パーミッションでオープンする．
<code>flag</code> の指定方法次第で，追記モードや，存在しない場合に作成する，等が可能になる．</p>

<p>例</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// os.OpenFile attempts to open given file as given mode and permission.
</span><span class="c1">// In this example, open &#34;newfile.txt&#34; as write-only mode and it permission is 0600 (r/w only allowed to file owner)
</span><span class="c1"></span><span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="s">&#34;newfile.txt&#34;</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="p">,</span> <span class="mo">0600</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span></code></pre></div>
<h2 id="おそらく-最も基本となる方法">（おそらく）最も基本となる方法</h2>

<p>ファイルをオープンし，バイト型のスライスを使ってデータの読み書きを行う方法．</p>

<h3 id="read">Read</h3>

<p>前提として，ファイルからの読み取りができるモードでオープンされている必要がある．</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;newfile.txt&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

<span class="c1">// *File.Read reads slice of bytes up to len(slice) from file.
</span><span class="c1"></span><span class="nx">buffer</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d bytes read by *File.Read()\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;file content: %s\n&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buffer</span><span class="p">))</span></code></pre></div>
<h3 id="write">Write</h3>

<p>前提として，ファイルに書き込みができるモードでオープンされている必要がある．</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// os.OpenFile attempts to open given file as given mode and permission.
</span><span class="c1">// In this example, open &#34;newfile.txt&#34; as write-only mode and it permission is 0600 (r/w only allowed to file owner)
</span><span class="c1"></span><span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="s">&#34;newfile.txt&#34;</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="p">,</span> <span class="mo">0600</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

<span class="c1">// *File.Write writes slice of bytes to file.
</span><span class="c1"></span><span class="nx">byteData</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;Hello world\n&#34;</span><span class="p">)</span>
<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">byteData</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d bytes written by os.Write()\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span></code></pre></div>
<p>また，バイト型のスライスの代わりにstringを書き込むこともできる．
stringの書き込みには <code>WriteString</code> メソッドを使用する．</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// *File.WriteString writes strings to file instead of slice of bytes.
</span><span class="c1"></span><span class="nx">stringData</span> <span class="o">:=</span> <span class="s">&#34;We can write not only []byte but also string :)&#34;</span>
<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">stringData</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d bytes written by os.WriteString()\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span></code></pre></div>
<h3 id="ファイルの内容すべてを読み込む">ファイルの内容すべてを読み込む</h3>

<p>io/ioutilパッケージの <code>ReadAll</code> メソッドを使用すると，ファイルの内容すべてを読み込むことができる．</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ReadAll</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span></code></pre></div>
<p>ReadAllの引数に与える <code>io.Reader</code> は， <code>Read</code> メソッドを持つインタフェースと定義されている．
そのため，通常通りオープンしたファイルをそのまま渡すことができる．</p>

<p>例</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;newfile.txt&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

<span class="nx">bytes</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Read all contents by ioutil.ReadAll(): %s\n&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">bytes</span><span class="p">))</span></code></pre></div>
<h2 id="バッファありのファイルi-o">バッファありのファイルI/O</h2>

<p>bufioパッケージのメソッドを使用すると，読み書きの際に内部でバッファを使ってくれる．
そのため，そのままデータを読み書きするよりも効率的に処理を行うことができる．</p>

<p>ファイルI/Oに使えそうなものは次の3種類．</p>

<ul>
<li>bufio.Reader</li>
<li>bufio.Scanner</li>
<li>bufio.Writer</li>
</ul>

<h3 id="bufio-reader">bufio.Reader</h3>

<p>基本的な使い方は通常のファイルと似ているが，いくつか便利なメソッドが定義されている．</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">reader</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
<span class="nx">buffer</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// basic Read method
</span><span class="c1"></span><span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">reader</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;content: %s\n&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buffer</span><span class="p">))</span>

<span class="c1">// ReadBytes reads until delimiter found.
</span><span class="c1">// Read contents is slice of bytes.
</span><span class="c1">// In this example, read until first &#39;\n&#39; character found.
</span><span class="c1"></span><span class="nx">bytes</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">reader</span><span class="p">.</span><span class="nf">ReadBytes</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;content: %s\n&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">bytes</span><span class="p">))</span>

<span class="c1">// ReadString reads until delimiter found.
</span><span class="c1">// Read contents is string.
</span><span class="c1">// In this example, read until first &#39;\n&#39; character found.
</span><span class="c1"></span><span class="nx">str</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">reader</span><span class="p">.</span><span class="nf">ReadString</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;content: %s\n&#34;</span><span class="p">,</span> <span class="nx">str</span><span class="p">)</span></code></pre></div>
<h3 id="bufio-scanner">bufio.Scanner</h3>

<p>bufio.Readerと似ているが，こちらは改行区切りのテキストを扱う時に便利なものになっている．</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;newfile.txt&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">scanner</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewScanner</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">scanner</span><span class="p">.</span><span class="nf">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">scanner</span><span class="p">.</span><span class="nf">Text</span><span class="p">())</span>
<span class="p">}</span></code></pre></div>
<p><code>Text</code> メソッドを呼ぶと，改行文字まで（＝1行分の文字）を返してくれる．</p>

<p><code>Scan</code> が <code>true</code> の間は，まだ読んでいない行があるということを示している．
なので， <code>Scan</code> が <code>false</code> になるまでループを回してあげれば結果的にファイルの内容すべてを読むことができる．</p>

<h3 id="bufio-writer">bufio.Writer</h3>

<p>Readerと同様，io.Writerと似ている．
注意しなければならない点として，最後に <code>Writer.Flush</code> を呼び出す必要がある点がある．
これを呼び出さないと正常に書き込みされないので注意する．</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="s">&#34;newfile.txt&#34;</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="p">,</span> <span class="mo">0600</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

<span class="nx">writer</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewWriter</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>

<span class="nx">byteData</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;Hello world\n&#34;</span><span class="p">)</span>
<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">writer</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">byteData</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d bytes written\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>

<span class="nx">stringData</span> <span class="o">:=</span> <span class="s">&#34;Write string :)&#34;</span>
<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">writer</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">stringData</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d bytes written\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>

<span class="nx">writer</span><span class="p">.</span><span class="nf">Flush</span><span class="p">()</span></code></pre></div>
<h2 id="references">References</h2>

<ul>
<li><a href="https://godoc.org/os">os - GoDoc</a></li>
<li><a href="https://godoc.org/io">io - GoDoc</a></li>
<li><a href="https://godoc.org/io/ioutil">ioutil - GoDoc</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Kubernetes Authentication</title>
			<link>https://www.mas9612.net/posts/k8s-auth/</link>
			<pubDate>Sun, 13 Jan 2019 00:00:00 +0900</pubDate>
			
			<guid>https://www.mas9612.net/posts/k8s-auth/</guid>
			<description>When we use Kubernetes API, the request is checked by following order after TLS is established[1].
 Authentication: Checked whether user is granted to access API Authorization: Checked whether user is granted to do requested action to specified object Admission Control: Modify or reject request  To test and study Kubernetes authentication flow, I was tested it with minikube.
Environment  Kubernetes cluster bootstrapped with minikube  $ kubectl version Client Version: version.</description>
			<content type="html"><![CDATA[

<p>When we use Kubernetes API, the request is checked by following order after TLS is established[1].</p>

<ol>
<li>Authentication: Checked whether user is granted to access API</li>
<li>Authorization: Checked whether user is granted to do requested action to specified object</li>
<li>Admission Control: Modify or reject request</li>
</ol>

<p>To test and study Kubernetes authentication flow, I was tested it with minikube.</p>

<h2 id="environment">Environment</h2>

<ul>
<li>Kubernetes cluster bootstrapped with minikube</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl version
Client Version: version.Info<span class="o">{</span>Major:<span class="s2">&#34;1&#34;</span>, Minor:<span class="s2">&#34;13&#34;</span>, GitVersion:<span class="s2">&#34;v1.13.1&#34;</span>, GitCommit:<span class="s2">&#34;eec55b9ba98609a46fee712359c7b5b365bdd920&#34;</span>, GitTreeState:<span class="s2">&#34;clean&#34;</span>, BuildDate:<span class="s2">&#34;2018-12-13T19:44:19Z&#34;</span>, GoVersion:<span class="s2">&#34;go1.11.2&#34;</span>, Compiler:<span class="s2">&#34;gc&#34;</span>, Platform:<span class="s2">&#34;darwin/amd64&#34;</span><span class="o">}</span>
Server Version: version.Info<span class="o">{</span>Major:<span class="s2">&#34;1&#34;</span>, Minor:<span class="s2">&#34;12&#34;</span>, GitVersion:<span class="s2">&#34;v1.12.4&#34;</span>, GitCommit:<span class="s2">&#34;f49fa022dbe63faafd0da106ef7e05a29721d3f1&#34;</span>, GitTreeState:<span class="s2">&#34;clean&#34;</span>, BuildDate:<span class="s2">&#34;2018-12-14T06:59:37Z&#34;</span>, GoVersion:<span class="s2">&#34;go1.10.4&#34;</span>, Compiler:<span class="s2">&#34;gc&#34;</span>, Platform:<span class="s2">&#34;linux/amd64&#34;</span><span class="o">}</span></code></pre></div>
<h2 id="authentication">Authentication</h2>

<p>In this test, we used X509 Client Certs (Client certificate authentication) as authentication strategy.
For more information about it or other authentication strategy, see [2].</p>

<p><strong>Procedure:</strong></p>

<ol>
<li>Create client key and CSR (Certificate Signing Request)</li>
<li>Sign CSR created in previous step with CA key</li>
<li>Register client key and certificate to kubectl config</li>
</ol>

<p>In minikube, client certificate authentication is enabled by default.
So we don&rsquo;t need to enable it manually.
Let&rsquo;s create client key and certificate.</p>

<h3 id="create-client-key-and-csr">Create client key and CSR</h3>

<p>First, we must create client key and CSR (Certificate Signing Request).
We can create these with <code>openssl</code> command.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># generate RSA private key (Algorithm: RSA, Key bits: 2048, Key name: client.key)</span>
$ openssl genpkey -algorithm rsa -pkeyopt rsa_keygen_bits:2048 -out client.key

<span class="c1"># generate CSR (Username: mas9612, Group: users)</span>
$ openssl req -new -key client.key -out client.csr -subj <span class="s2">&#34;/CN=mas9612/O=users&#34;</span></code></pre></div>
<p>When issuing CSR, we must pass username and group at <code>-subj</code> option.
<code>CN</code> means username, <code>O</code> means group. User can be associated with multiple groups.
To add user more than one groups, simply add <code>O</code> section to <code>-subj</code> option.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># user mas9612 is now a member of &#34;users&#34; and &#34;member&#34; groups</span>
$ openssl req -new -key client.key -out client.csr -subj <span class="s2">&#34;/CN=mas9612/O=users/O=member&#34;</span></code></pre></div>
<h3 id="sign-csr-with-ca-key">Sign CSR with CA key</h3>

<p>After create CSR, we must sign it with CA (Certificate Authority) key.</p>

<p>First, we must fetch CA key and certificate from minikube VM.
We can do that with following commands.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ minikube ssh
$ sudo cp /var/lib/minikube/certs/ca.crt /var/lib/minikube/certs/ca.key ~
$ sudo chown <span class="k">$(</span>id -u<span class="k">)</span>:<span class="k">$(</span>id -g<span class="k">)</span> ~/ca.crt ~/ca.key
$ <span class="nb">exit</span>

$ scp -i <span class="k">$(</span>minikube ssh-key<span class="k">)</span> docker@<span class="k">$(</span>minikube ip<span class="k">)</span>:~/ca.crt .
$ scp -i <span class="k">$(</span>minikube ssh-key<span class="k">)</span> docker@<span class="k">$(</span>minikube ip<span class="k">)</span>:~/ca.key .</code></pre></div>
<p>Finally, sign CSR with fetch key and certificate.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial <span class="se">\
</span><span class="se"></span>    -out client.crt -days <span class="m">3650</span></code></pre></div>
<p>To check created certificate, run following command.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl x509 -in client.crt -text -noout</code></pre></div>
<h2 id="register-client-key-and-certificate-to-kubectl-config">Register client key and certificate to kubectl config</h2>

<p>After create client key and certificate, we should register it to kubectl config to use it easily.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># create &#34;testuser&#34; with given key and certificate</span>
$ kubectl config set-credentials testuser --client-key<span class="o">=</span>./client.key --client-certificate<span class="o">=</span>./client.crt

<span class="c1"># bind &#34;testuser&#34; and minikube cluster as &#34;authtest&#34; context</span>
$ kubectl config set-context authtest --cluster<span class="o">=</span>minikube --user<span class="o">=</span>testuser

<span class="c1"># change to use &#34;authtest&#34; context instead of minikube default</span>
$ kubectl config use-context authtest</code></pre></div>
<p>After register credentials, we can use kubectl command as created user.
But now, we aren&rsquo;t granted to use any API so any request will be rejected.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl get pods
Error from server <span class="o">(</span>Forbidden<span class="o">)</span>: pods is forbidden: User <span class="s2">&#34;mas9612&#34;</span> cannot list resource <span class="s2">&#34;pods&#34;</span> in API group <span class="s2">&#34;&#34;</span> in the namespace <span class="s2">&#34;default&#34;</span></code></pre></div>
<p>To allow API request, we must assign appropriate Role to User.</p>

<h2 id="authorization">Authorization</h2>

<p>In the previous section, we tried to create new user and to query running pod information.
We confirmed that user is properly created but any operation is not allowed.</p>

<p>In this section, we will examine Kubernetes RBAC API.</p>

<h3 id="role-clusterrole-rolebinding-clusterrolebinding-5">Role/ClusterRole, RoleBinding/ClusterRoleBinding[5]</h3>

<p>Kubernetes RBAC API has 4 types: Role, ClusterRole, RoleBinding, ClusterRoleBinding.</p>

<p>Types prefixed by <code>Cluster-</code> have cluster-wide effect.
In contrast, types non-prefixed by <code>Cluster-</code> have only specific namespace (e.g. <code>default</code> namespace)</p>

<p>Role/ClusterRole contains rules that represent a set of permissions.
Default permission is all deny so you must add some rule to allow operation (e.g. list pods, create new deployment, etc.).</p>

<p>RoleBinding/ClusterRoleBinding grants the permissions to a user (or a set of users).</p>

<p>So if we want to add some permission to user, first create appropriate Role and then bind it to user by RoleBinding.</p>

<h3 id="create-role">Create Role</h3>

<p>Let&rsquo;s create Role to list running pods in default namespace.
Create <code>client-role.yml</code> with the following content.</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml">kind<span class="p">:</span><span class="w"> </span>Role<span class="w">
</span><span class="w"></span>apiVersion<span class="p">:</span><span class="w"> </span>rbac.authorization.k8s.io/v1<span class="w">
</span><span class="w"></span>metadata<span class="p">:</span><span class="w">
</span><span class="w">  </span>namespace<span class="p">:</span><span class="w"> </span>default<span class="w">
</span><span class="w">  </span>name<span class="p">:</span><span class="w"> </span>test-role<span class="w">
</span><span class="w"></span>rules<span class="p">:</span><span class="w">
</span><span class="w">  </span>-<span class="w"> </span>apiGroups<span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;&#34;</span><span class="p">]</span><span class="w">
</span><span class="w">    </span>resources<span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;pods&#34;</span><span class="p">]</span><span class="w">
</span><span class="w">    </span>verbs<span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;get&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;watch&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;list&#34;</span><span class="p">]</span></code></pre></div>
<p>After create manifest, apply it with kubectl:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># make sure that we&#39;re using minikube context</span>
$ kubectl config use-context minikube

$ kubectl apply -f client-role.yml
role.rbac.authorization.k8s.io/test-role created

<span class="c1"># check Role is created properly</span>
$ kubectl get role
NAME        AGE
test-role   102s</code></pre></div>
<h3 id="create-rolebinding">Create RoleBinding</h3>

<p>Next, we create RoleBinding to bind User and Role.
Create <code>client-rolebinding.yml</code> with the following content.</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml">kind<span class="p">:</span><span class="w"> </span>RoleBinding<span class="w">
</span><span class="w"></span>apiVersion<span class="p">:</span><span class="w"> </span>rbac.authorization.k8s.io/v1<span class="w">
</span><span class="w"></span>metadata<span class="p">:</span><span class="w">
</span><span class="w">  </span>name<span class="p">:</span><span class="w"> </span>client-read-access<span class="w">
</span><span class="w">  </span>namespace<span class="p">:</span><span class="w"> </span>default<span class="w">
</span><span class="w"></span>subjects<span class="p">:</span><span class="w">
</span><span class="w">  </span>-<span class="w"> </span>kind<span class="p">:</span><span class="w"> </span>User<span class="w">
</span><span class="w">    </span>name<span class="p">:</span><span class="w"> </span>mas9612<span class="w">
</span><span class="w">    </span>apiGroup<span class="p">:</span><span class="w"> </span>rbac.authorization.k8s.io<span class="w">
</span><span class="w"></span>roleRef<span class="p">:</span><span class="w">
</span><span class="w">  </span>kind<span class="p">:</span><span class="w"> </span>Role<span class="w">
</span><span class="w">  </span>name<span class="p">:</span><span class="w"> </span>test-role<span class="w">
</span><span class="w">  </span>apiGroup<span class="p">:</span><span class="w"> </span>rbac.authorization.k8s.io</code></pre></div>
<p>Please change username to that you created.</p>

<p>After create manifest, apply it with kubectl:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl apply -f client-rolebinding.yml
rolebinding.rbac.authorization.k8s.io/client-read-access created

$ kubectl get rolebindings
NAME                 AGE
client-read-access   48s</code></pre></div>
<p>Finally, change context to <code>auth-test</code> and try to query pods again!</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl config use-context auth-test
Switched to context <span class="s2">&#34;auth-test&#34;</span>.

$ kubectl get pods
No resources found.</code></pre></div>
<h2 id="references">References</h2>

<ul>
<li>[1] <a href="https://kubernetes.io/docs/reference/access-authn-authz/controlling-access/">Controlling Access to the Kubernetes API - Kubernetes</a></li>
<li>[2] <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/">Authenticating - Kubernetes</a></li>
<li>[3] <a href="https://kubernetes.io/docs/concepts/cluster-administration/certificates/#openssl">Certificates - Kubernetes</a></li>
<li>[4] <a href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/">Authorization Overview - Kubernetes</a></li>
<li>[5] <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">Using RBAC Authorization - Kubernetes</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>pipeによるプロセス間通信</title>
			<link>https://www.mas9612.net/posts/pipe/</link>
			<pubDate>Sat, 08 Dec 2018 00:00:00 +0900</pubDate>
			
			<guid>https://www.mas9612.net/posts/pipe/</guid>
			<description>fork() で作成した子プロセスと親プロセスの間で情報のやり取りをするために，IPC（Inter Process Communication）の一つであるパイプを利用</description>
			<content type="html"><![CDATA[

<p><code>fork()</code> で作成した子プロセスと親プロセスの間で情報のやり取りをするために，IPC（Inter Process Communication）の一つであるパイプを利用した．
一度理解してしまえば特に難しいものではなかったので，文章としてまとめておく．</p>

<h2 id="パイプの概要">パイプの概要</h2>

<p>シェルを使用していると，「何かのコマンドの出力をgrepしたい」というとき等，あるコマンドの出力を別のコマンドの入力として扱いたいということが多々ある．このような場合，「パイプ」という機能を使って次のようにコマンドを実行することで実現できる．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ cat something.txt <span class="p">|</span> grep Hello</code></pre></div>
<p>上記のコマンドを実行すると，catコマンドの出力から， <code>Hello</code> を含んでいる行のみを画面に出力させることができる．
（上記の例ではパイプを使わずともgrepコマンド単体で同じことが可能であるが）</p>

<p>このように，パイプの入口・出口となるファイルディスクリプタを接続することができるという機能を持つ．</p>

<h2 id="パイプの利用">パイプの利用</h2>

<p>次のような簡単なサンプルプログラムを作成した．</p>

<script src="https://gist.github.com/mas9612/31ed12c2d4d3f8ea13938600c46b3dce.js"></script>

<p>特に難しいことはやっておらず，ただ単に <code>fork()</code> した後，親プロセスから子プロセスに文字列を送るだけのプログラム．</p>

<p>パイプを使うため， <code>fork()</code> を呼び出す前に <code>pipe()</code> を呼び出しておく．
<code>pipe()</code> システムコールを呼び出すと，引数に与えた配列の0番目に「読み取り用」，1番目に「書き込み用」のファイルディスクリプタを格納してくれる．
これらに対して書き込み・読み取りをすると，それぞれ対応するファイルディスクリプタから読み取り・書き込みを行うことができる．</p>

<p><code>pipe()</code> を呼び出した跡は通常通り <code>fork()</code> を呼び出す．
これにより，子プロセスが作成され， <code>pipe()</code> によって作成されたファイルディスクリプタのペアも複製される．
その後，親プロセスと子プロセスで，次の必要ないファイルディスクリプタをそれぞれクローズしておく．</p>

<ul>
<li>親プロセス→読み取り用のファイルディスクリプタ（ <code>fds[0]</code> ）

<ul>
<li>親プロセスからは書き込みのみを行うため</li>
</ul></li>
<li>子プロセス→書き込み用のファイルディスクリプタ（ <code>fds[1]</code> ）

<ul>
<li>子プロセスからは読み取りのみを行うため</li>
</ul></li>
</ul>

<p>あとは，通常通り <code>read()</code> や <code>write()</code> を呼び出すだけ．</p>

<p>今回は， <code>fork()</code> した後でも親・子ともに同じプログラムを実行していたが， <code>execve()</code> 等を使って子プロセスでは別のプログラムを動作させることももちろん可能．
この場合，子プロセスで標準入力からデータを読み込みたい場合は， <code>dup2()</code> を使って <code>fds[0]</code> を <code>0</code> （標準入力）に複製してあげると良い．</p>

<h2 id="参考文献">参考文献</h2>

<ul>
<li>Michael Kerrisk，Linuxプログラミングインタフェース，2012年12月 発行，ISBN978-4-87311-585-6</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>OpenSSLでTLS証明書を作る</title>
			<link>https://www.mas9612.net/posts/openssl/</link>
			<pubDate>Wed, 14 Nov 2018 00:00:00 +0900</pubDate>
			
			<guid>https://www.mas9612.net/posts/openssl/</guid>
			<description>etcdクラスタをTLS有効にして運用するため，TLS証明書を作成する必要があった． ちゃんとした手順をあまり理解できていなかったため，備忘録</description>
			<content type="html"><![CDATA[

<p>etcdクラスタをTLS有効にして運用するため，TLS証明書を作成する必要があった．
ちゃんとした手順をあまり理解できていなかったため，備忘録として残しておく．</p>

<h2 id="tls証明書発行までの流れ">TLS証明書発行までの流れ</h2>

<p>TLS証明書は次にような流れで発行する．</p>

<ol>
<li>秘密鍵を作成</li>
<li>CSRを作成</li>
<li>TLS証明書を作成</li>
</ol>

<p>これ以降，上記の具体的な手順について説明する．</p>

<p>今回使用したOpenSSLのバージョンは次の通り．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl version
OpenSSL <span class="m">1</span>.1.1  <span class="m">11</span> Sep <span class="m">2018</span></code></pre></div>
<h3 id="秘密鍵を作成">秘密鍵を作成</h3>

<p>秘密鍵の作成は， <code>genpkey</code> サブコマンドを使用する．
<code>genrsa</code> サブコマンドでもできるようだが，マニュアルに <code>genrsa</code> 含めいくつかのコマンドは <code>genpkey</code> に置き換えられたという記述があるので，今回は <code>genpkey</code> を使用する．</p>

<p>今回は次のような鍵を作成する．</p>

<ul>
<li>公開鍵アルゴリズム: RSA</li>
<li>鍵長: 2048bit</li>
<li>秘密鍵を暗号化するためのアルゴリズム: AES 128bit</li>
</ul>

<p>この条件で秘密鍵を作成するには次のようなコマンドを使用する．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl genpkey -algorithm rsa -pkeyopt rsa_keygen_bits:2048 -aes128 -out ca.key</code></pre></div>
<p>コマンドを実行するとパスフレーズを求められるので，適当なものを入力する．
実行すると次のようになる．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl genpkey -algorithm rsa -pkeyopt rsa_keygen_bits:2048 -aes128 -out ca.key
..........................................................+++++
................................................+++++
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:</code></pre></div>
<p>オプションの意味は次の通り．</p>

<ul>
<li><code>-algorithm rsa</code> : 公開鍵アルゴリズムとしてRSAを使用する</li>
<li><code>-pkeyopt rsa_keygen_bits:2048</code> : RSAの鍵長を2048bitにする</li>
<li><code>-aes128</code> : 秘密鍵をAES 128bitで暗号化する</li>
<li><code>-out ca.key</code> : <code>ca.key</code> という名前で秘密鍵を生成する</li>
</ul>

<h3 id="csrを作成">CSRを作成</h3>

<p>TLS証明書を作成するには，まずCSR (Certificate Signing Request) を作成する必要がある．
このCSRを元に，CA (Certificate Authority) がTLS証明書を作成するという流れになる．</p>

<p>この手順では，前手順で作成した秘密鍵を使ってCSRを作成する．
これは <code>req</code> サブコマンドで行うことができる．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl req -new -key ca.key -out ca.csr</code></pre></div>
<p>実行すると次のようになる．
まずパスフレーズを聞かれるので，秘密鍵を作成したときに入力したのと同じものを入力する．</p>

<p>その後，いくつか情報を聞かれるので必要に応じて入力する．
このとき，何も入力せずにEnterを押すとデフォルト値が使用されるが，フィールドを空にしておきたい場合は <code>.</code> （ピリオド）を入力してからEnterを押すようにする．
<code>.</code> をつけることにより，このフィールドは空だと明示的に指定できる．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl req -new -key ca.key -out ca.csr
Enter pass phrase <span class="k">for</span> ca.key:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class="s1">&#39;.&#39;</span>, the field will be left blank.
-----
Country Name <span class="o">(</span><span class="m">2</span> letter code<span class="o">)</span> <span class="o">[</span>AU<span class="o">]</span>:JP
State or Province Name <span class="o">(</span>full name<span class="o">)</span> <span class="o">[</span>Some-State<span class="o">]</span>:.
Locality Name <span class="o">(</span>eg, city<span class="o">)</span> <span class="o">[]</span>:.
Organization Name <span class="o">(</span>eg, company<span class="o">)</span> <span class="o">[</span>Internet Widgits Pty Ltd<span class="o">]</span>:.
Organizational Unit Name <span class="o">(</span>eg, section<span class="o">)</span> <span class="o">[]</span>:.
Common Name <span class="o">(</span>e.g. server FQDN or YOUR name<span class="o">)</span> <span class="o">[]</span>:mas9612.net
Email Address <span class="o">[]</span>:.

Please enter the following <span class="s1">&#39;extra&#39;</span> attributes
to be sent with your certificate request
A challenge password <span class="o">[]</span>:.
An optional company name <span class="o">[]</span>:.</code></pre></div>
<p>オプションの意味は次の通り．</p>

<ul>
<li><code>-new</code> : 新しいCSRを作成するときに指定する</li>
<li><code>-key ca.key</code> : 秘密鍵を指定する．この鍵とペアになる公開鍵が署名される</li>
<li><code>-out ca.csr</code> : <code>ca.csr</code> という名前でCSRを作成する</li>
</ul>

<h3 id="tls証明書を作成">TLS証明書を作成</h3>

<p>CSRが作成できたら，最後にTLS証明書を作成する．</p>

<p>今回は，次の2種類の方法を試す．</p>

<ul>
<li>自己署名: 自分の秘密鍵を使って署名する</li>
<li>別に用意したCAによる署名: CAの秘密鍵を使って署名する</li>
</ul>

<h4 id="自己署名">自己署名</h4>

<p>自己署名を行うには，次のようなコマンドを実行する．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl x509 -req -in ca.csr -out ca.crt -signkey ca.key -days <span class="m">365</span></code></pre></div>
<p>コマンドを実行すると次のようになる．
ここでもパスフレーズを聞かれるので，秘密鍵作成時のものを入力する．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl x509 -req -in ca.csr -out ca.crt -signkey ca.key -days <span class="m">365</span>
Signature ok
<span class="nv">subject</span><span class="o">=</span><span class="nv">C</span> <span class="o">=</span> JP, <span class="nv">CN</span> <span class="o">=</span> mas9612.net
Getting Private key
Enter pass phrase <span class="k">for</span> ca.key:</code></pre></div>
<p>オプションの意味は次の通り．</p>

<ul>
<li><code>-req</code> : このオプションを指定すると，CSRを読み込んでTLS証明書を作成する</li>
<li><code>-in ca.csr</code> : 読み込むCSRファイルを指定</li>
<li><code>-out ca.crt</code> : <code>ca.crt</code> という名前でTLS証明書を出力する</li>
<li><code>-signkey ca.key</code> : <code>ca.key</code> を使って署名を行う</li>
<li><code>-days 365</code> : TLS証明書の期限を365日にする</li>
</ul>

<h4 id="caによる署名">CAによる署名</h4>

<p>次に，CAによる署名を試してみる．
といっても，自分で何かCAを運用しているわけではないので，今回は先程作った秘密鍵とTLS証明書をCAのものと仮定し，それを使って署名をするということを試す．</p>

<p>まず，先ほどとは別の秘密鍵とCSRを作成しておく．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl genpkey -algorithm rsa -pkeyopt rsa_keygen_bits:2048 -aes128 -out etcd0.key
$ openssl req -new -key ca.key -out etcd0.csr</code></pre></div>
<p>CSRまで作成できたら，それをCAの証明書で署名する手順に移る．
これも自己署名と同様に， <code>x509</code> サブコマンドを使うと簡単にできる．
次のようなコマンドを実行する．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl x509 -req -in etcd0.csr -out etcd0-ca.crt -days <span class="m">365</span> -CA ca.crt -CAkey ca.key -CAcreateserial</code></pre></div>
<p>実行すると次のようになる．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl x509 -req -in etcd0.csr -out etcd0-ca.crt -days <span class="m">365</span> -CA ca.crt -CAkey ca.key -CAcreateserial
Signature ok
<span class="nv">subject</span><span class="o">=</span><span class="nv">C</span> <span class="o">=</span> JP, <span class="nv">CN</span> <span class="o">=</span> mas9612.net
Getting CA Private Key
Enter pass phrase <span class="k">for</span> ca.key:</code></pre></div>
<p>CA関連のオプションは次の通り．</p>

<ul>
<li><code>-CA ca.crt</code> : 署名に使用するCAのTLS証明書を指定する</li>
<li><code>-CAkey ca.key</code> : 署名に使用するCA秘密鍵を指定する</li>
<li><code>-CAcreateserial</code> : CAのシリアルナンバーファイルが存在しない場合，自動で作成する</li>
</ul>

<h2 id="秘密鍵やcsr-tls証明書の内容を確認する">秘密鍵やCSR，TLS証明書の内容を確認する</h2>

<p>上記の手順でTLS証明書までの作成ができた．
作成した各種ファイルは，opensslコマンドを使用することでその内容を確認することができる．</p>

<p>ここではそれについて説明する．</p>

<h3 id="秘密鍵の内容確認">秘密鍵の内容確認</h3>

<p>秘密鍵の内容を確認するには， <code>rsa</code> サブコマンドを使用する．</p>

<p>普通に秘密鍵を読み込むには， <code>-in</code> オプションに秘密鍵のファイル名を指定するだけでできる．
なお，このコマンドを実行してもただ単にファイルの内容がそのまま表示されるだけである．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl rsa -in ca.key
Enter pass phrase <span class="k">for</span> ca.key:
writing RSA key
-----BEGIN RSA PRIVATE KEY-----
MIIEogIBAAKCAQEAoTo44Vgr5vUZvhlfhDGrUK3DBVKexWoG5Hq29oMhEc5HCSTk
XBL28/gGVoW6NtW7HMiM2zkPE0ETC/Hi8ef9CVjE414F5OpIgppBjYxjjmDEDita
...（省略）
bBxlNDpyMteIfxg1cix3U2V+D1mWhBAKqF95xJNASQZtfeabZHZzCH7YbO0eGFIv
m9ZFXwYPhq+ORWBJE9+hL1PsgvkiruEECIKTE2Pfeb8TkiO1Gls<span class="o">=</span>
-----END RSA PRIVATE KEY-----</code></pre></div>
<p>これに <code>-text</code> オプションを指定すると，秘密鍵の内容を調べてNやE，Dを値を表示してくれる．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl rsa -in ca.key -text
Enter pass phrase <span class="k">for</span> ca.key:
RSA Private-Key: <span class="o">(</span><span class="m">2048</span> bit, <span class="m">2</span> primes<span class="o">)</span>
modulus:
    <span class="m">00</span>:a1:3a:38:e1:58:2b:e6:f5:19:be:19:5f:84:31:
    ...（省略）
    <span class="m">43</span>:c8:f7:b1:7f:e0:9f:5f:9c:25:83:55:1d:d4:b7:
    de:9f
publicExponent: <span class="m">65537</span> <span class="o">(</span>0x10001<span class="o">)</span>
privateExponent:
    <span class="m">58</span>:d7:6d:5a:77:2c:91:f2:c3:81:a6:17:a5:0f:7d:
    ...（省略）
    b4:d7:70:bb:59:56:df:92:9f:99:40:a4:42:97:4d:
    c9
prime1:
    <span class="m">00</span>:d1:a0:9d:d8:96:8d:8d:48:d0:76:c8:76:8e:b9:
    ...（諸略）
    a0:30:e1:b3:b5:d2:e8:d4:00:f3:65:93:ab:d5:b3:
    2f:0e:aa:bd:94:75:2d:a2:05
prime2:
    <span class="m">00</span>:c4:e4:ac:2a:c5:59:aa:a1:d2:3c:2a:8c:dd:bf:
    ...（省略）
    bf:32:c3:4b:98:dc:57🆎53
exponent1:
    4c:d1:5f:06:8f:a5:2f:b1:0f:33:78:22:7a:0a:ef:
    ...（省略）
    ac:16:45:82:b1:ae:17:41
exponent2:
    <span class="m">41</span>:b8:e3:0f:53:d8:de:70:2d:b1:0f:b2:fd:c2:17:
    ...（省略）
    ee:9d:e9:fa:18:72:db:29
coefficient:
    2f:ba:6e:47:c5:bb:60:2e:4f:35:4f:c2:d1:12:61:
    ...（省略）
    <span class="m">79</span>:bf:13:92:23:b5:1a:5b
writing RSA key
-----BEGIN RSA PRIVATE KEY-----
MIIEogIBAAKCAQEAoTo44Vgr5vUZvhlfhDGrUK3DBVKexWoG5Hq29oMhEc5HCSTk
XBL28/gGVoW6NtW7HMiM2zkPE0ETC/Hi8ef9CVjE414F5OpIgppBjYxjjmDEDita
...（省略）
m9ZFXwYPhq+ORWBJE9+hL1PsgvkiruEECIKTE2Pfeb8TkiO1Gls<span class="o">=</span>
-----END RSA PRIVATE KEY-----</code></pre></div>
<p>いろいろ出力されるが，NやEに対応するのは次の部分．</p>

<ul>
<li>N: modulus</li>
<li>E: publicExponent</li>
<li>D: privateExponent</li>
<li>prime1: p</li>
<li>prime2: q</li>
</ul>

<p>また， <code>-noout</code> オプションを指定すると，秘密鍵をエンコーディングした内容は出力されなくなる（ <code>BEGIN RSA PRIVATE KEY</code> から <code>END RSA PRIVATE KEY</code> の部分）．</p>

<h3 id="csrの内容確認">CSRの内容確認</h3>

<p>CSRの内容確認には， <code>req</code> サブコマンドを使用する．
秘密鍵の内容確認と同じように， <code>-in</code> ， <code>-text</code> ， <code>-noout</code> が使える．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl req -in ca.csr -text -noout</code></pre></div>
<h3 id="tls証明書の内容確認">TLS証明書の内容確認</h3>

<p>TLS証明書の内容確認には， <code>x509</code> サブコマンドを使用する．
これも同じように， <code>-in</code> ， <code>-text</code> ， <code>-noout</code> が使える．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ openssl x509 -in ca.crt -text -noout</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>etcd入門</title>
			<link>https://www.mas9612.net/posts/etcd/</link>
			<pubDate>Sat, 27 Oct 2018 00:00:00 +0900</pubDate>
			
			<guid>https://www.mas9612.net/posts/etcd/</guid>
			<description>Kubernetesにも採用されている分散型KVSについて，何回かに分けて勉強していく． 今回のモチベーションとして，Kubernetesのア</description>
			<content type="html"><![CDATA[

<p>Kubernetesにも採用されている分散型KVSについて，何回かに分けて勉強していく．
今回のモチベーションとして，Kubernetesのアーキテクチャを詳しく勉強したい，Terraformのstate保存をローカルではなくetcdにしたいという2つがある．</p>

<p>まず，インストールとクラスタの作成について見ていく．</p>

<h2 id="インストール">インストール</h2>

<p>クラスタ作成のためには，まずetcd本体のバイナリが必要になる．
<a href="https://github.com/etcd-io/etcd/releases">GitHubのreleaseページ</a>から，自分のOSにあったバイナリをダウンロードしてくる．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ curl -LO https://github.com/etcd-io/etcd/releases/download/v3.3.10/etcd-v3.3.10-linux-amd64.tar.gz</code></pre></div>
<p>ダウンロードしたファイルは圧縮されており，それを解凍するといくつかのファイルの中に2つのバイナリが確認できる．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ tar xzf etcd-v3.3.10-linux-amd64.tar.gz
$ <span class="nb">cd</span> etcd-v3.3.10-linux-amd64.tar.gz
$ ll etcd*
-rwxr-xr-x. <span class="m">1</span> yamazaki yamazaki <span class="m">19237536</span> Oct <span class="m">11</span>  <span class="m">2018</span> etcd
-rwxr-xr-x. <span class="m">1</span> yamazaki yamazaki <span class="m">15817472</span> Oct <span class="m">11</span>  <span class="m">2018</span> etcdctl</code></pre></div>
<p><code>etcd</code> はetcd本体， <code>etcdctl</code> はetcdのクライアントとなるプログラム．
これら2つをPATHが通っている場所に置いてあげる．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ sudo mv etcd* /usr/local/bin/
$ ll /usr/local/bin/etcd*
-rwxr-xr-x. <span class="m">1</span> yamazaki yamazaki <span class="m">19237536</span> Oct <span class="m">11</span>  <span class="m">2018</span> /usr/local/bin/etcd
-rwxr-xr-x. <span class="m">1</span> yamazaki yamazaki <span class="m">15817472</span> Oct <span class="m">11</span>  <span class="m">2018</span> /usr/local/bin/etcdctl</code></pre></div>
<p>これでインストールは完了．
きちんとインストールされているか一応確認する．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ etcd --version
etcd Version: <span class="m">3</span>.3.10
Git SHA: 27fc7e2
Go Version: go1.10.4
Go OS/Arch: linux/amd64</code></pre></div>
<h2 id="クラスタの作成">クラスタの作成</h2>

<p>まず，1台のみでetcdクラスタを作成して簡単に使い方を把握し，その後複数メンバでのetcdクラスタを作成していく．</p>

<h3 id="1台のetcdクラスタ作成">1台のetcdクラスタ作成</h3>

<p>基本的に<a href="https://github.com/etcd-io/etcd#running-etcd">GitHubに書いてある手順</a>通りに試していく．</p>

<p>1台のみでetcdクラスタを作成するときは，特に何も考えずに <code>etcd</code> コマンドを実行する．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ etcd</code></pre></div>
<p><code>etcd</code> コマンドを実行すると，多くのログが出力される．
ここで，作成したetcdクラスタを使って，データの登録と取得を試してみる．</p>

<p>etcdクラスタとのやり取りには， <code>etcdctl</code> コマンドを使用する．
<code>etcd</code> コマンドを実行しているシェルとは別にもう1つシェルを起動し，そこで <code>etcdctl</code> コマンドを使用していく．
なお，etcd APIにはバージョンがいくつかあるが，今回はバージョン3を使用する．
<strong><code>etcdctl</code> を普通に使うとv2 APIが使われてしまうので，v3 APIを使うために <code>ETCDCTL_API</code> という環境変数の値を <code>3</code> に設定する必要があることに注意する．</strong>
公式のREADMEのように <code>etcdctl</code> コマンドを実行するごとに毎回 <code>ETCDCTL_API</code> を指定してもよいが，毎回記述するのも面倒なのであらかじめexportしておく．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">export</span> <span class="nv">ETCDCTL_API</span><span class="o">=</span><span class="m">3</span></code></pre></div>
<p>etcdクラスタにデータを登録するには，putコマンドを使用する．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Usage</span>
$ etcdctl put &lt;key&gt; &lt;value&gt;

$ etcdctl put mykey <span class="s2">&#34;this is awesome&#34;</span>
OK</code></pre></div>
<p>putコマンドを実行して， <code>OK</code> と表示されれば成功している．</p>

<p>登録した値を取得するにはgetコマンドを使用する．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Usage</span>
$ etcdctl get &lt;key&gt;

$ etcdctl get mykey
mykey
this is awesome</code></pre></div>
<p>指定したキーの名前とデータが続けて出力されれば成功．</p>

<p>次に，複数台のetcdクラスタを作成してみる．
その前に，今使っていたetcdクラスタを停止させておく．
<code>etcd</code> コマンドを実行していたシェルに戻り，Ctrl-Cで終了する．</p>

<h3 id="複数メンバでのetcdクラスタ作成">複数メンバでのetcdクラスタ作成</h3>

<p>今回は1つのノードの中にetcdを複数立ち上げることで，複数メンバで構成されるetcdクラスタを作成する．
もちろん，複数のノードを使ってノード1台につきetcdを1つ動作させるという形で作成することもできる．</p>

<p>公式には，etcdはTCP 2379番・2380番のポートを使用する．</p>

<ul>
<li>2379/tcp: クライアントとの通信</li>
<li>2380/tcp: etcdメンバ間の通信</li>
</ul>

<p>今回は同じノード内に複数etcdを立ち上げるため，それぞれのetcdでポートが競合しないようにしておく．
今回は3つのetcdメンバを動作させ，それぞれの名前，ポートは次の表のようにした．</p>

<table>
<thead>
<tr>
<th align="left">メンバ</th>
<th align="right">クライアント通信用</th>
<th align="right">メンバ間通信用</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">etcd1</td>
<td align="right">2379</td>
<td align="right">2380</td>
</tr>

<tr>
<td align="left">etcd2</td>
<td align="right">12379</td>
<td align="right">12380</td>
</tr>

<tr>
<td align="left">etcd3</td>
<td align="right">22379</td>
<td align="right">22380</td>
</tr>
</tbody>
</table>

<p>実際に3つのetcdメンバを動かしていく．
ターミナルのウィンドウを3つ開いて，それぞれのターミナルにつき1つのetcdメンバを起動する．
それぞれのターミナルで，次のようなコマンドを実行する．</p>

<p>1つ目のターミナル</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ etcd --name etcd1 <span class="se">\
</span><span class="se"></span>    --initial-advertise-peer-urls http://localhost:2380 <span class="se">\
</span><span class="se"></span>    --listen-peer-urls http://localhost:2380 <span class="se">\
</span><span class="se"></span>    --advertise-client-urls http://localhost:2379 <span class="se">\
</span><span class="se"></span>    --listen-client-urls http://localhost:2379 <span class="se">\
</span><span class="se"></span>    --initial-cluster <span class="nv">etcd1</span><span class="o">=</span>http://localhost:2380,etcd2<span class="o">=</span>http://localhost:12380,etcd3<span class="o">=</span>http://localhost:22380 <span class="se">\
</span><span class="se"></span>    --initial-cluster-state new <span class="se">\
</span><span class="se"></span>    --initial-cluster-token etcd-cluster-1</code></pre></div>
<p>2つ目のターミナル</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ etcd --name etcd2 <span class="se">\
</span><span class="se"></span>    --initial-advertise-peer-urls http://localhost:12380 <span class="se">\
</span><span class="se"></span>    --listen-peer-urls http://localhost:12380 <span class="se">\
</span><span class="se"></span>    --advertise-client-urls http://localhost:12379 <span class="se">\
</span><span class="se"></span>    --listen-client-urls http://localhost:12379 <span class="se">\
</span><span class="se"></span>    --initial-cluster <span class="nv">etcd1</span><span class="o">=</span>http://localhost:2380,etcd2<span class="o">=</span>http://localhost:12380,etcd3<span class="o">=</span>http://localhost:22380 <span class="se">\
</span><span class="se"></span>    --initial-cluster-state new <span class="se">\
</span><span class="se"></span>    --initial-cluster-token etcd-cluster-1</code></pre></div>
<p>3つ目のターミナル</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ etcd --name etcd3 <span class="se">\
</span><span class="se"></span>    --initial-advertise-peer-urls http://localhost:22380 <span class="se">\
</span><span class="se"></span>    --listen-peer-urls http://localhost:22380 <span class="se">\
</span><span class="se"></span>    --advertise-client-urls http://localhost:22379 <span class="se">\
</span><span class="se"></span>    --listen-client-urls http://localhost:22379 <span class="se">\
</span><span class="se"></span>    --initial-cluster <span class="nv">etcd</span><span class="o">=</span>http://localhost:2380,etcd2<span class="o">=</span>http://localhost:12380,etcd3<span class="o">=</span>http://localhost:22380 <span class="se">\
</span><span class="se"></span>    --initial-cluster-state new <span class="se">\
</span><span class="se"></span>    --initial-cluster-token etcd-cluster-1</code></pre></div>
<p>正しくコマンドを入力できていれば，正常にetcdクラスタが起動しているはず．
出力されるログでエラー等が出ていなければひとまずOK．</p>

<p>コマンドラインオプションをたくさん使っているので複雑に見えるが，一度理解してしまうとそこまで難しくはないと思う．
今回指定しているコマンドラインオプションは，大きく分けて次の2つに分かれている．</p>

<ul>
<li>新しいクラスタを作成するときに使用するもの（<a href="https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/configuration.md#clustering-flags">Clustering flags</a>）</li>
<li>他のメンバやクライアントとの通信や，etcdの設定に関するもの（<a href="https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/configuration.md#member-flags">Member flags</a>）</li>
</ul>

<p>Clustering flagsでは，新しいクラスタを一から作成するときに必要となる情報を指定する．
今回使用したものは次の通り．</p>

<table>
<thead>
<tr>
<th align="left">flags</th>
<th align="left">description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>--initial-advertise-peer-urls</code></td>
<td align="left">クラスタ内の他のetcdメンバからの通信を受け付けるURLを指定する</td>
</tr>

<tr>
<td align="left"><code>--advertise-client-urls</code></td>
<td align="left">クライアントからの通信を受け付けるURLを指定する</td>
</tr>

<tr>
<td align="left"><code>--initial-cluster</code></td>
<td align="left">クラスタを構成するetcdメンバの情報をカンマ区切りで指定する</td>
</tr>

<tr>
<td align="left"><code>--initial-cluster-state</code></td>
<td align="left">新しいクラスタを作成する場合は <code>new</code> を指定する</td>
</tr>

<tr>
<td align="left"><code>--initial-cluster-token</code></td>
<td align="left">クラスタ作成中に用いられるトークン．複数クラスタを管理している際，意図せず別のクラスタに影響を与えるのを防ぐ</td>
</tr>
</tbody>
</table>

<p>Member flagsでは，作成するメンバに関する情報等の設定ができる．
今回使用したものは次の通り．</p>

<table>
<thead>
<tr>
<th align="left">flags</th>
<th align="left">description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>--name</code></td>
<td align="left">メンバ名</td>
</tr>

<tr>
<td align="left"><code>--listen-peer-urls</code></td>
<td align="left">クラスタ内の他のetcdメンバからの通信を受け付けるURLを指定する</td>
</tr>

<tr>
<td align="left"><code>--listen-client-urls</code></td>
<td align="left">クライアントからの通信を受け付けるURLを指定する</td>
</tr>
</tbody>
</table>

<p>注意点として， <code>--initial-cluster</code> で指定しているメンバ情報は， <code>--name</code> と <code>--listen-peer-urls</code> で指定した名前とURLに一致させなければならない．
もし一致していないと，クラスタ起動時にエラーとなる．</p>

<p>次のコマンドで，きちんと3つのメンバが表示されたら成功．</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ etcdctl member list
29727fd1bdf9fb62, started, etcd1, http://localhost:2380, http://localhost:2379
44dd3cd8faa339d0, started, etcd3, http://localhost:22380, http://localhost:22379
b59b01c27098773e, started, etcd2, http://localhost:12380, http://localhost:12379</code></pre></div>
<p>次は，作成したクラスタを使ってもう少しetcdctlの使い方を勉強し，その後TLSの設定やDiscoveryを使ったクラスタ作成，無停止でのメンバアップグレード等について勉強していく予定．</p>
]]></content>
		</item>
		
	</channel>
</rss>
